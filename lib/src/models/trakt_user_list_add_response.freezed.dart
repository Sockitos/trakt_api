// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'trakt_user_list_add_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TraktUserListAddResponse _$TraktUserListAddResponseFromJson(
    Map<String, dynamic> json) {
  return _TraktUserListAddResponse.fromJson(json);
}

/// @nodoc
mixin _$TraktUserListAddResponse {
  TraktUserListAddResponseAdded get added => throw _privateConstructorUsedError;
  TraktUserListAddResponseExisting get existing =>
      throw _privateConstructorUsedError;
  TraktUserListAddResponseNotFound get notFound =>
      throw _privateConstructorUsedError;
  TraktUserListAddResponseList get list => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserListAddResponseCopyWith<TraktUserListAddResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserListAddResponseCopyWith<$Res> {
  factory $TraktUserListAddResponseCopyWith(TraktUserListAddResponse value,
          $Res Function(TraktUserListAddResponse) then) =
      _$TraktUserListAddResponseCopyWithImpl<$Res, TraktUserListAddResponse>;
  @useResult
  $Res call(
      {TraktUserListAddResponseAdded added,
      TraktUserListAddResponseExisting existing,
      TraktUserListAddResponseNotFound notFound,
      TraktUserListAddResponseList list});

  $TraktUserListAddResponseAddedCopyWith<$Res> get added;
  $TraktUserListAddResponseExistingCopyWith<$Res> get existing;
  $TraktUserListAddResponseNotFoundCopyWith<$Res> get notFound;
  $TraktUserListAddResponseListCopyWith<$Res> get list;
}

/// @nodoc
class _$TraktUserListAddResponseCopyWithImpl<$Res,
        $Val extends TraktUserListAddResponse>
    implements $TraktUserListAddResponseCopyWith<$Res> {
  _$TraktUserListAddResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? existing = null,
    Object? notFound = null,
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseAdded,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseNotFound,
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseList,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserListAddResponseAddedCopyWith<$Res> get added {
    return $TraktUserListAddResponseAddedCopyWith<$Res>(_value.added, (value) {
      return _then(_value.copyWith(added: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserListAddResponseExistingCopyWith<$Res> get existing {
    return $TraktUserListAddResponseExistingCopyWith<$Res>(_value.existing,
        (value) {
      return _then(_value.copyWith(existing: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserListAddResponseNotFoundCopyWith<$Res> get notFound {
    return $TraktUserListAddResponseNotFoundCopyWith<$Res>(_value.notFound,
        (value) {
      return _then(_value.copyWith(notFound: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserListAddResponseListCopyWith<$Res> get list {
    return $TraktUserListAddResponseListCopyWith<$Res>(_value.list, (value) {
      return _then(_value.copyWith(list: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TraktUserListAddResponseCopyWith<$Res>
    implements $TraktUserListAddResponseCopyWith<$Res> {
  factory _$$_TraktUserListAddResponseCopyWith(
          _$_TraktUserListAddResponse value,
          $Res Function(_$_TraktUserListAddResponse) then) =
      __$$_TraktUserListAddResponseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TraktUserListAddResponseAdded added,
      TraktUserListAddResponseExisting existing,
      TraktUserListAddResponseNotFound notFound,
      TraktUserListAddResponseList list});

  @override
  $TraktUserListAddResponseAddedCopyWith<$Res> get added;
  @override
  $TraktUserListAddResponseExistingCopyWith<$Res> get existing;
  @override
  $TraktUserListAddResponseNotFoundCopyWith<$Res> get notFound;
  @override
  $TraktUserListAddResponseListCopyWith<$Res> get list;
}

/// @nodoc
class __$$_TraktUserListAddResponseCopyWithImpl<$Res>
    extends _$TraktUserListAddResponseCopyWithImpl<$Res,
        _$_TraktUserListAddResponse>
    implements _$$_TraktUserListAddResponseCopyWith<$Res> {
  __$$_TraktUserListAddResponseCopyWithImpl(_$_TraktUserListAddResponse _value,
      $Res Function(_$_TraktUserListAddResponse) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? existing = null,
    Object? notFound = null,
    Object? list = null,
  }) {
    return _then(_$_TraktUserListAddResponse(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseAdded,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseNotFound,
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as TraktUserListAddResponseList,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserListAddResponse implements _TraktUserListAddResponse {
  const _$_TraktUserListAddResponse(
      {required this.added,
      required this.existing,
      required this.notFound,
      required this.list});

  factory _$_TraktUserListAddResponse.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserListAddResponseFromJson(json);

  @override
  final TraktUserListAddResponseAdded added;
  @override
  final TraktUserListAddResponseExisting existing;
  @override
  final TraktUserListAddResponseNotFound notFound;
  @override
  final TraktUserListAddResponseList list;

  @override
  String toString() {
    return 'TraktUserListAddResponse(added: $added, existing: $existing, notFound: $notFound, list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserListAddResponse &&
            (identical(other.added, added) || other.added == added) &&
            (identical(other.existing, existing) ||
                other.existing == existing) &&
            (identical(other.notFound, notFound) ||
                other.notFound == notFound) &&
            (identical(other.list, list) || other.list == list));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, added, existing, notFound, list);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserListAddResponseCopyWith<_$_TraktUserListAddResponse>
      get copyWith => __$$_TraktUserListAddResponseCopyWithImpl<
          _$_TraktUserListAddResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserListAddResponseToJson(
      this,
    );
  }
}

abstract class _TraktUserListAddResponse implements TraktUserListAddResponse {
  const factory _TraktUserListAddResponse(
          {required final TraktUserListAddResponseAdded added,
          required final TraktUserListAddResponseExisting existing,
          required final TraktUserListAddResponseNotFound notFound,
          required final TraktUserListAddResponseList list}) =
      _$_TraktUserListAddResponse;

  factory _TraktUserListAddResponse.fromJson(Map<String, dynamic> json) =
      _$_TraktUserListAddResponse.fromJson;

  @override
  TraktUserListAddResponseAdded get added;
  @override
  TraktUserListAddResponseExisting get existing;
  @override
  TraktUserListAddResponseNotFound get notFound;
  @override
  TraktUserListAddResponseList get list;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserListAddResponseCopyWith<_$_TraktUserListAddResponse>
      get copyWith => throw _privateConstructorUsedError;
}

TraktUserListAddResponseAdded _$TraktUserListAddResponseAddedFromJson(
    Map<String, dynamic> json) {
  return _TraktUserListAddResponseAdded.fromJson(json);
}

/// @nodoc
mixin _$TraktUserListAddResponseAdded {
  int get movies => throw _privateConstructorUsedError;
  int get shows => throw _privateConstructorUsedError;
  int get seasons => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;
  int get people => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserListAddResponseAddedCopyWith<TraktUserListAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserListAddResponseAddedCopyWith<$Res> {
  factory $TraktUserListAddResponseAddedCopyWith(
          TraktUserListAddResponseAdded value,
          $Res Function(TraktUserListAddResponseAdded) then) =
      _$TraktUserListAddResponseAddedCopyWithImpl<$Res,
          TraktUserListAddResponseAdded>;
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes, int people});
}

/// @nodoc
class _$TraktUserListAddResponseAddedCopyWithImpl<$Res,
        $Val extends TraktUserListAddResponseAdded>
    implements $TraktUserListAddResponseAddedCopyWith<$Res> {
  _$TraktUserListAddResponseAddedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
      people: null == people
          ? _value.people
          : people // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserListAddResponseAddedCopyWith<$Res>
    implements $TraktUserListAddResponseAddedCopyWith<$Res> {
  factory _$$_TraktUserListAddResponseAddedCopyWith(
          _$_TraktUserListAddResponseAdded value,
          $Res Function(_$_TraktUserListAddResponseAdded) then) =
      __$$_TraktUserListAddResponseAddedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes, int people});
}

/// @nodoc
class __$$_TraktUserListAddResponseAddedCopyWithImpl<$Res>
    extends _$TraktUserListAddResponseAddedCopyWithImpl<$Res,
        _$_TraktUserListAddResponseAdded>
    implements _$$_TraktUserListAddResponseAddedCopyWith<$Res> {
  __$$_TraktUserListAddResponseAddedCopyWithImpl(
      _$_TraktUserListAddResponseAdded _value,
      $Res Function(_$_TraktUserListAddResponseAdded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_$_TraktUserListAddResponseAdded(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
      people: null == people
          ? _value.people
          : people // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserListAddResponseAdded
    implements _TraktUserListAddResponseAdded {
  const _$_TraktUserListAddResponseAdded(
      {required this.movies,
      required this.shows,
      required this.seasons,
      required this.episodes,
      required this.people});

  factory _$_TraktUserListAddResponseAdded.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktUserListAddResponseAddedFromJson(json);

  @override
  final int movies;
  @override
  final int shows;
  @override
  final int seasons;
  @override
  final int episodes;
  @override
  final int people;

  @override
  String toString() {
    return 'TraktUserListAddResponseAdded(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes, people: $people)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserListAddResponseAdded &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.shows, shows) || other.shows == shows) &&
            (identical(other.seasons, seasons) || other.seasons == seasons) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes) &&
            (identical(other.people, people) || other.people == people));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, movies, shows, seasons, episodes, people);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserListAddResponseAddedCopyWith<_$_TraktUserListAddResponseAdded>
      get copyWith => __$$_TraktUserListAddResponseAddedCopyWithImpl<
          _$_TraktUserListAddResponseAdded>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserListAddResponseAddedToJson(
      this,
    );
  }
}

abstract class _TraktUserListAddResponseAdded
    implements TraktUserListAddResponseAdded {
  const factory _TraktUserListAddResponseAdded(
      {required final int movies,
      required final int shows,
      required final int seasons,
      required final int episodes,
      required final int people}) = _$_TraktUserListAddResponseAdded;

  factory _TraktUserListAddResponseAdded.fromJson(Map<String, dynamic> json) =
      _$_TraktUserListAddResponseAdded.fromJson;

  @override
  int get movies;
  @override
  int get shows;
  @override
  int get seasons;
  @override
  int get episodes;
  @override
  int get people;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserListAddResponseAddedCopyWith<_$_TraktUserListAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

TraktUserListAddResponseExisting _$TraktUserListAddResponseExistingFromJson(
    Map<String, dynamic> json) {
  return _TraktUserListAddResponseExisting.fromJson(json);
}

/// @nodoc
mixin _$TraktUserListAddResponseExisting {
  int get movies => throw _privateConstructorUsedError;
  int get shows => throw _privateConstructorUsedError;
  int get seasons => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;
  int get people => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserListAddResponseExistingCopyWith<TraktUserListAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserListAddResponseExistingCopyWith<$Res> {
  factory $TraktUserListAddResponseExistingCopyWith(
          TraktUserListAddResponseExisting value,
          $Res Function(TraktUserListAddResponseExisting) then) =
      _$TraktUserListAddResponseExistingCopyWithImpl<$Res,
          TraktUserListAddResponseExisting>;
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes, int people});
}

/// @nodoc
class _$TraktUserListAddResponseExistingCopyWithImpl<$Res,
        $Val extends TraktUserListAddResponseExisting>
    implements $TraktUserListAddResponseExistingCopyWith<$Res> {
  _$TraktUserListAddResponseExistingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
      people: null == people
          ? _value.people
          : people // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserListAddResponseExistingCopyWith<$Res>
    implements $TraktUserListAddResponseExistingCopyWith<$Res> {
  factory _$$_TraktUserListAddResponseExistingCopyWith(
          _$_TraktUserListAddResponseExisting value,
          $Res Function(_$_TraktUserListAddResponseExisting) then) =
      __$$_TraktUserListAddResponseExistingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes, int people});
}

/// @nodoc
class __$$_TraktUserListAddResponseExistingCopyWithImpl<$Res>
    extends _$TraktUserListAddResponseExistingCopyWithImpl<$Res,
        _$_TraktUserListAddResponseExisting>
    implements _$$_TraktUserListAddResponseExistingCopyWith<$Res> {
  __$$_TraktUserListAddResponseExistingCopyWithImpl(
      _$_TraktUserListAddResponseExisting _value,
      $Res Function(_$_TraktUserListAddResponseExisting) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_$_TraktUserListAddResponseExisting(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
      people: null == people
          ? _value.people
          : people // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserListAddResponseExisting
    implements _TraktUserListAddResponseExisting {
  const _$_TraktUserListAddResponseExisting(
      {required this.movies,
      required this.shows,
      required this.seasons,
      required this.episodes,
      required this.people});

  factory _$_TraktUserListAddResponseExisting.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktUserListAddResponseExistingFromJson(json);

  @override
  final int movies;
  @override
  final int shows;
  @override
  final int seasons;
  @override
  final int episodes;
  @override
  final int people;

  @override
  String toString() {
    return 'TraktUserListAddResponseExisting(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes, people: $people)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserListAddResponseExisting &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.shows, shows) || other.shows == shows) &&
            (identical(other.seasons, seasons) || other.seasons == seasons) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes) &&
            (identical(other.people, people) || other.people == people));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, movies, shows, seasons, episodes, people);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserListAddResponseExistingCopyWith<
          _$_TraktUserListAddResponseExisting>
      get copyWith => __$$_TraktUserListAddResponseExistingCopyWithImpl<
          _$_TraktUserListAddResponseExisting>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserListAddResponseExistingToJson(
      this,
    );
  }
}

abstract class _TraktUserListAddResponseExisting
    implements TraktUserListAddResponseExisting {
  const factory _TraktUserListAddResponseExisting(
      {required final int movies,
      required final int shows,
      required final int seasons,
      required final int episodes,
      required final int people}) = _$_TraktUserListAddResponseExisting;

  factory _TraktUserListAddResponseExisting.fromJson(
      Map<String, dynamic> json) = _$_TraktUserListAddResponseExisting.fromJson;

  @override
  int get movies;
  @override
  int get shows;
  @override
  int get seasons;
  @override
  int get episodes;
  @override
  int get people;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserListAddResponseExistingCopyWith<
          _$_TraktUserListAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

TraktUserListAddResponseNotFound _$TraktUserListAddResponseNotFoundFromJson(
    Map<String, dynamic> json) {
  return _TraktUserListAddResponseNotFound.fromJson(json);
}

/// @nodoc
mixin _$TraktUserListAddResponseNotFound {
  List<TraktUserListAddMovie> get movies => throw _privateConstructorUsedError;
  List<TraktUserListAddShow> get shows => throw _privateConstructorUsedError;
  List<TraktUserListAddSeason> get seasons =>
      throw _privateConstructorUsedError;
  List<TraktUserListAddEpisode> get episodes =>
      throw _privateConstructorUsedError;
  List<TraktUserListAddPerson> get people => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserListAddResponseNotFoundCopyWith<TraktUserListAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserListAddResponseNotFoundCopyWith<$Res> {
  factory $TraktUserListAddResponseNotFoundCopyWith(
          TraktUserListAddResponseNotFound value,
          $Res Function(TraktUserListAddResponseNotFound) then) =
      _$TraktUserListAddResponseNotFoundCopyWithImpl<$Res,
          TraktUserListAddResponseNotFound>;
  @useResult
  $Res call(
      {List<TraktUserListAddMovie> movies,
      List<TraktUserListAddShow> shows,
      List<TraktUserListAddSeason> seasons,
      List<TraktUserListAddEpisode> episodes,
      List<TraktUserListAddPerson> people});
}

/// @nodoc
class _$TraktUserListAddResponseNotFoundCopyWithImpl<$Res,
        $Val extends TraktUserListAddResponseNotFound>
    implements $TraktUserListAddResponseNotFoundCopyWith<$Res> {
  _$TraktUserListAddResponseNotFoundCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddMovie>,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddShow>,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddSeason>,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddEpisode>,
      people: null == people
          ? _value.people
          : people // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddPerson>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserListAddResponseNotFoundCopyWith<$Res>
    implements $TraktUserListAddResponseNotFoundCopyWith<$Res> {
  factory _$$_TraktUserListAddResponseNotFoundCopyWith(
          _$_TraktUserListAddResponseNotFound value,
          $Res Function(_$_TraktUserListAddResponseNotFound) then) =
      __$$_TraktUserListAddResponseNotFoundCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TraktUserListAddMovie> movies,
      List<TraktUserListAddShow> shows,
      List<TraktUserListAddSeason> seasons,
      List<TraktUserListAddEpisode> episodes,
      List<TraktUserListAddPerson> people});
}

/// @nodoc
class __$$_TraktUserListAddResponseNotFoundCopyWithImpl<$Res>
    extends _$TraktUserListAddResponseNotFoundCopyWithImpl<$Res,
        _$_TraktUserListAddResponseNotFound>
    implements _$$_TraktUserListAddResponseNotFoundCopyWith<$Res> {
  __$$_TraktUserListAddResponseNotFoundCopyWithImpl(
      _$_TraktUserListAddResponseNotFound _value,
      $Res Function(_$_TraktUserListAddResponseNotFound) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? people = null,
  }) {
    return _then(_$_TraktUserListAddResponseNotFound(
      movies: null == movies
          ? _value._movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddMovie>,
      shows: null == shows
          ? _value._shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddShow>,
      seasons: null == seasons
          ? _value._seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddSeason>,
      episodes: null == episodes
          ? _value._episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddEpisode>,
      people: null == people
          ? _value._people
          : people // ignore: cast_nullable_to_non_nullable
              as List<TraktUserListAddPerson>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserListAddResponseNotFound
    implements _TraktUserListAddResponseNotFound {
  const _$_TraktUserListAddResponseNotFound(
      {final List<TraktUserListAddMovie> movies =
          const <TraktUserListAddMovie>[],
      final List<TraktUserListAddShow> shows = const <TraktUserListAddShow>[],
      final List<TraktUserListAddSeason> seasons =
          const <TraktUserListAddSeason>[],
      final List<TraktUserListAddEpisode> episodes =
          const <TraktUserListAddEpisode>[],
      final List<TraktUserListAddPerson> people =
          const <TraktUserListAddPerson>[]})
      : _movies = movies,
        _shows = shows,
        _seasons = seasons,
        _episodes = episodes,
        _people = people;

  factory _$_TraktUserListAddResponseNotFound.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktUserListAddResponseNotFoundFromJson(json);

  final List<TraktUserListAddMovie> _movies;
  @override
  @JsonKey()
  List<TraktUserListAddMovie> get movies {
    if (_movies is EqualUnmodifiableListView) return _movies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_movies);
  }

  final List<TraktUserListAddShow> _shows;
  @override
  @JsonKey()
  List<TraktUserListAddShow> get shows {
    if (_shows is EqualUnmodifiableListView) return _shows;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_shows);
  }

  final List<TraktUserListAddSeason> _seasons;
  @override
  @JsonKey()
  List<TraktUserListAddSeason> get seasons {
    if (_seasons is EqualUnmodifiableListView) return _seasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_seasons);
  }

  final List<TraktUserListAddEpisode> _episodes;
  @override
  @JsonKey()
  List<TraktUserListAddEpisode> get episodes {
    if (_episodes is EqualUnmodifiableListView) return _episodes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_episodes);
  }

  final List<TraktUserListAddPerson> _people;
  @override
  @JsonKey()
  List<TraktUserListAddPerson> get people {
    if (_people is EqualUnmodifiableListView) return _people;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_people);
  }

  @override
  String toString() {
    return 'TraktUserListAddResponseNotFound(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes, people: $people)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserListAddResponseNotFound &&
            const DeepCollectionEquality().equals(other._movies, _movies) &&
            const DeepCollectionEquality().equals(other._shows, _shows) &&
            const DeepCollectionEquality().equals(other._seasons, _seasons) &&
            const DeepCollectionEquality().equals(other._episodes, _episodes) &&
            const DeepCollectionEquality().equals(other._people, _people));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_movies),
      const DeepCollectionEquality().hash(_shows),
      const DeepCollectionEquality().hash(_seasons),
      const DeepCollectionEquality().hash(_episodes),
      const DeepCollectionEquality().hash(_people));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserListAddResponseNotFoundCopyWith<
          _$_TraktUserListAddResponseNotFound>
      get copyWith => __$$_TraktUserListAddResponseNotFoundCopyWithImpl<
          _$_TraktUserListAddResponseNotFound>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserListAddResponseNotFoundToJson(
      this,
    );
  }
}

abstract class _TraktUserListAddResponseNotFound
    implements TraktUserListAddResponseNotFound {
  const factory _TraktUserListAddResponseNotFound(
          {final List<TraktUserListAddMovie> movies,
          final List<TraktUserListAddShow> shows,
          final List<TraktUserListAddSeason> seasons,
          final List<TraktUserListAddEpisode> episodes,
          final List<TraktUserListAddPerson> people}) =
      _$_TraktUserListAddResponseNotFound;

  factory _TraktUserListAddResponseNotFound.fromJson(
      Map<String, dynamic> json) = _$_TraktUserListAddResponseNotFound.fromJson;

  @override
  List<TraktUserListAddMovie> get movies;
  @override
  List<TraktUserListAddShow> get shows;
  @override
  List<TraktUserListAddSeason> get seasons;
  @override
  List<TraktUserListAddEpisode> get episodes;
  @override
  List<TraktUserListAddPerson> get people;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserListAddResponseNotFoundCopyWith<
          _$_TraktUserListAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}

TraktUserListAddResponseList _$TraktUserListAddResponseListFromJson(
    Map<String, dynamic> json) {
  return _TraktUserListAddResponseList.fromJson(json);
}

/// @nodoc
mixin _$TraktUserListAddResponseList {
  DateTime get updatedAt => throw _privateConstructorUsedError;
  int get itemCount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserListAddResponseListCopyWith<TraktUserListAddResponseList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserListAddResponseListCopyWith<$Res> {
  factory $TraktUserListAddResponseListCopyWith(
          TraktUserListAddResponseList value,
          $Res Function(TraktUserListAddResponseList) then) =
      _$TraktUserListAddResponseListCopyWithImpl<$Res,
          TraktUserListAddResponseList>;
  @useResult
  $Res call({DateTime updatedAt, int itemCount});
}

/// @nodoc
class _$TraktUserListAddResponseListCopyWithImpl<$Res,
        $Val extends TraktUserListAddResponseList>
    implements $TraktUserListAddResponseListCopyWith<$Res> {
  _$TraktUserListAddResponseListCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updatedAt = null,
    Object? itemCount = null,
  }) {
    return _then(_value.copyWith(
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      itemCount: null == itemCount
          ? _value.itemCount
          : itemCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserListAddResponseListCopyWith<$Res>
    implements $TraktUserListAddResponseListCopyWith<$Res> {
  factory _$$_TraktUserListAddResponseListCopyWith(
          _$_TraktUserListAddResponseList value,
          $Res Function(_$_TraktUserListAddResponseList) then) =
      __$$_TraktUserListAddResponseListCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DateTime updatedAt, int itemCount});
}

/// @nodoc
class __$$_TraktUserListAddResponseListCopyWithImpl<$Res>
    extends _$TraktUserListAddResponseListCopyWithImpl<$Res,
        _$_TraktUserListAddResponseList>
    implements _$$_TraktUserListAddResponseListCopyWith<$Res> {
  __$$_TraktUserListAddResponseListCopyWithImpl(
      _$_TraktUserListAddResponseList _value,
      $Res Function(_$_TraktUserListAddResponseList) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updatedAt = null,
    Object? itemCount = null,
  }) {
    return _then(_$_TraktUserListAddResponseList(
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      itemCount: null == itemCount
          ? _value.itemCount
          : itemCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserListAddResponseList implements _TraktUserListAddResponseList {
  const _$_TraktUserListAddResponseList(
      {required this.updatedAt, required this.itemCount});

  factory _$_TraktUserListAddResponseList.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserListAddResponseListFromJson(json);

  @override
  final DateTime updatedAt;
  @override
  final int itemCount;

  @override
  String toString() {
    return 'TraktUserListAddResponseList(updatedAt: $updatedAt, itemCount: $itemCount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserListAddResponseList &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.itemCount, itemCount) ||
                other.itemCount == itemCount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, updatedAt, itemCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserListAddResponseListCopyWith<_$_TraktUserListAddResponseList>
      get copyWith => __$$_TraktUserListAddResponseListCopyWithImpl<
          _$_TraktUserListAddResponseList>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserListAddResponseListToJson(
      this,
    );
  }
}

abstract class _TraktUserListAddResponseList
    implements TraktUserListAddResponseList {
  const factory _TraktUserListAddResponseList(
      {required final DateTime updatedAt,
      required final int itemCount}) = _$_TraktUserListAddResponseList;

  factory _TraktUserListAddResponseList.fromJson(Map<String, dynamic> json) =
      _$_TraktUserListAddResponseList.fromJson;

  @override
  DateTime get updatedAt;
  @override
  int get itemCount;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserListAddResponseListCopyWith<_$_TraktUserListAddResponseList>
      get copyWith => throw _privateConstructorUsedError;
}
