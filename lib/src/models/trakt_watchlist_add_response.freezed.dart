// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'trakt_watchlist_add_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TraktWatchlistAddResponse _$TraktWatchlistAddResponseFromJson(
    Map<String, dynamic> json) {
  return _TraktWatchlistAddResponse.fromJson(json);
}

/// @nodoc
mixin _$TraktWatchlistAddResponse {
  TraktWatchlistAddResponseAdded get added =>
      throw _privateConstructorUsedError;
  TraktWatchlistAddResponseExisting get existing =>
      throw _privateConstructorUsedError;
  TraktWatchlistAddResponseNotFound get notFound =>
      throw _privateConstructorUsedError;
  TraktWatchlistAddResponseList get list => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktWatchlistAddResponseCopyWith<TraktWatchlistAddResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktWatchlistAddResponseCopyWith<$Res> {
  factory $TraktWatchlistAddResponseCopyWith(TraktWatchlistAddResponse value,
          $Res Function(TraktWatchlistAddResponse) then) =
      _$TraktWatchlistAddResponseCopyWithImpl<$Res, TraktWatchlistAddResponse>;
  @useResult
  $Res call(
      {TraktWatchlistAddResponseAdded added,
      TraktWatchlistAddResponseExisting existing,
      TraktWatchlistAddResponseNotFound notFound,
      TraktWatchlistAddResponseList list});

  $TraktWatchlistAddResponseAddedCopyWith<$Res> get added;
  $TraktWatchlistAddResponseExistingCopyWith<$Res> get existing;
  $TraktWatchlistAddResponseNotFoundCopyWith<$Res> get notFound;
  $TraktWatchlistAddResponseListCopyWith<$Res> get list;
}

/// @nodoc
class _$TraktWatchlistAddResponseCopyWithImpl<$Res,
        $Val extends TraktWatchlistAddResponse>
    implements $TraktWatchlistAddResponseCopyWith<$Res> {
  _$TraktWatchlistAddResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? existing = null,
    Object? notFound = null,
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseAdded,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseNotFound,
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseList,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktWatchlistAddResponseAddedCopyWith<$Res> get added {
    return $TraktWatchlistAddResponseAddedCopyWith<$Res>(_value.added, (value) {
      return _then(_value.copyWith(added: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktWatchlistAddResponseExistingCopyWith<$Res> get existing {
    return $TraktWatchlistAddResponseExistingCopyWith<$Res>(_value.existing,
        (value) {
      return _then(_value.copyWith(existing: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktWatchlistAddResponseNotFoundCopyWith<$Res> get notFound {
    return $TraktWatchlistAddResponseNotFoundCopyWith<$Res>(_value.notFound,
        (value) {
      return _then(_value.copyWith(notFound: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktWatchlistAddResponseListCopyWith<$Res> get list {
    return $TraktWatchlistAddResponseListCopyWith<$Res>(_value.list, (value) {
      return _then(_value.copyWith(list: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TraktWatchlistAddResponseCopyWith<$Res>
    implements $TraktWatchlistAddResponseCopyWith<$Res> {
  factory _$$_TraktWatchlistAddResponseCopyWith(
          _$_TraktWatchlistAddResponse value,
          $Res Function(_$_TraktWatchlistAddResponse) then) =
      __$$_TraktWatchlistAddResponseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TraktWatchlistAddResponseAdded added,
      TraktWatchlistAddResponseExisting existing,
      TraktWatchlistAddResponseNotFound notFound,
      TraktWatchlistAddResponseList list});

  @override
  $TraktWatchlistAddResponseAddedCopyWith<$Res> get added;
  @override
  $TraktWatchlistAddResponseExistingCopyWith<$Res> get existing;
  @override
  $TraktWatchlistAddResponseNotFoundCopyWith<$Res> get notFound;
  @override
  $TraktWatchlistAddResponseListCopyWith<$Res> get list;
}

/// @nodoc
class __$$_TraktWatchlistAddResponseCopyWithImpl<$Res>
    extends _$TraktWatchlistAddResponseCopyWithImpl<$Res,
        _$_TraktWatchlistAddResponse>
    implements _$$_TraktWatchlistAddResponseCopyWith<$Res> {
  __$$_TraktWatchlistAddResponseCopyWithImpl(
      _$_TraktWatchlistAddResponse _value,
      $Res Function(_$_TraktWatchlistAddResponse) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? existing = null,
    Object? notFound = null,
    Object? list = null,
  }) {
    return _then(_$_TraktWatchlistAddResponse(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseAdded,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseNotFound,
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as TraktWatchlistAddResponseList,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktWatchlistAddResponse implements _TraktWatchlistAddResponse {
  const _$_TraktWatchlistAddResponse(
      {required this.added,
      required this.existing,
      required this.notFound,
      required this.list});

  factory _$_TraktWatchlistAddResponse.fromJson(Map<String, dynamic> json) =>
      _$$_TraktWatchlistAddResponseFromJson(json);

  @override
  final TraktWatchlistAddResponseAdded added;
  @override
  final TraktWatchlistAddResponseExisting existing;
  @override
  final TraktWatchlistAddResponseNotFound notFound;
  @override
  final TraktWatchlistAddResponseList list;

  @override
  String toString() {
    return 'TraktWatchlistAddResponse(added: $added, existing: $existing, notFound: $notFound, list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktWatchlistAddResponse &&
            (identical(other.added, added) || other.added == added) &&
            (identical(other.existing, existing) ||
                other.existing == existing) &&
            (identical(other.notFound, notFound) ||
                other.notFound == notFound) &&
            (identical(other.list, list) || other.list == list));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, added, existing, notFound, list);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktWatchlistAddResponseCopyWith<_$_TraktWatchlistAddResponse>
      get copyWith => __$$_TraktWatchlistAddResponseCopyWithImpl<
          _$_TraktWatchlistAddResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktWatchlistAddResponseToJson(
      this,
    );
  }
}

abstract class _TraktWatchlistAddResponse implements TraktWatchlistAddResponse {
  const factory _TraktWatchlistAddResponse(
          {required final TraktWatchlistAddResponseAdded added,
          required final TraktWatchlistAddResponseExisting existing,
          required final TraktWatchlistAddResponseNotFound notFound,
          required final TraktWatchlistAddResponseList list}) =
      _$_TraktWatchlistAddResponse;

  factory _TraktWatchlistAddResponse.fromJson(Map<String, dynamic> json) =
      _$_TraktWatchlistAddResponse.fromJson;

  @override
  TraktWatchlistAddResponseAdded get added;
  @override
  TraktWatchlistAddResponseExisting get existing;
  @override
  TraktWatchlistAddResponseNotFound get notFound;
  @override
  TraktWatchlistAddResponseList get list;
  @override
  @JsonKey(ignore: true)
  _$$_TraktWatchlistAddResponseCopyWith<_$_TraktWatchlistAddResponse>
      get copyWith => throw _privateConstructorUsedError;
}

TraktWatchlistAddResponseAdded _$TraktWatchlistAddResponseAddedFromJson(
    Map<String, dynamic> json) {
  return _TraktWatchlistAddResponseAdded.fromJson(json);
}

/// @nodoc
mixin _$TraktWatchlistAddResponseAdded {
  int get movies => throw _privateConstructorUsedError;
  int get shows => throw _privateConstructorUsedError;
  int get seasons => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktWatchlistAddResponseAddedCopyWith<TraktWatchlistAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktWatchlistAddResponseAddedCopyWith<$Res> {
  factory $TraktWatchlistAddResponseAddedCopyWith(
          TraktWatchlistAddResponseAdded value,
          $Res Function(TraktWatchlistAddResponseAdded) then) =
      _$TraktWatchlistAddResponseAddedCopyWithImpl<$Res,
          TraktWatchlistAddResponseAdded>;
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes});
}

/// @nodoc
class _$TraktWatchlistAddResponseAddedCopyWithImpl<$Res,
        $Val extends TraktWatchlistAddResponseAdded>
    implements $TraktWatchlistAddResponseAddedCopyWith<$Res> {
  _$TraktWatchlistAddResponseAddedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktWatchlistAddResponseAddedCopyWith<$Res>
    implements $TraktWatchlistAddResponseAddedCopyWith<$Res> {
  factory _$$_TraktWatchlistAddResponseAddedCopyWith(
          _$_TraktWatchlistAddResponseAdded value,
          $Res Function(_$_TraktWatchlistAddResponseAdded) then) =
      __$$_TraktWatchlistAddResponseAddedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes});
}

/// @nodoc
class __$$_TraktWatchlistAddResponseAddedCopyWithImpl<$Res>
    extends _$TraktWatchlistAddResponseAddedCopyWithImpl<$Res,
        _$_TraktWatchlistAddResponseAdded>
    implements _$$_TraktWatchlistAddResponseAddedCopyWith<$Res> {
  __$$_TraktWatchlistAddResponseAddedCopyWithImpl(
      _$_TraktWatchlistAddResponseAdded _value,
      $Res Function(_$_TraktWatchlistAddResponseAdded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktWatchlistAddResponseAdded(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktWatchlistAddResponseAdded
    implements _TraktWatchlistAddResponseAdded {
  const _$_TraktWatchlistAddResponseAdded(
      {required this.movies,
      required this.shows,
      required this.seasons,
      required this.episodes});

  factory _$_TraktWatchlistAddResponseAdded.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktWatchlistAddResponseAddedFromJson(json);

  @override
  final int movies;
  @override
  final int shows;
  @override
  final int seasons;
  @override
  final int episodes;

  @override
  String toString() {
    return 'TraktWatchlistAddResponseAdded(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktWatchlistAddResponseAdded &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.shows, shows) || other.shows == shows) &&
            (identical(other.seasons, seasons) || other.seasons == seasons) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, movies, shows, seasons, episodes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktWatchlistAddResponseAddedCopyWith<_$_TraktWatchlistAddResponseAdded>
      get copyWith => __$$_TraktWatchlistAddResponseAddedCopyWithImpl<
          _$_TraktWatchlistAddResponseAdded>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktWatchlistAddResponseAddedToJson(
      this,
    );
  }
}

abstract class _TraktWatchlistAddResponseAdded
    implements TraktWatchlistAddResponseAdded {
  const factory _TraktWatchlistAddResponseAdded(
      {required final int movies,
      required final int shows,
      required final int seasons,
      required final int episodes}) = _$_TraktWatchlistAddResponseAdded;

  factory _TraktWatchlistAddResponseAdded.fromJson(Map<String, dynamic> json) =
      _$_TraktWatchlistAddResponseAdded.fromJson;

  @override
  int get movies;
  @override
  int get shows;
  @override
  int get seasons;
  @override
  int get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktWatchlistAddResponseAddedCopyWith<_$_TraktWatchlistAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

TraktWatchlistAddResponseExisting _$TraktWatchlistAddResponseExistingFromJson(
    Map<String, dynamic> json) {
  return _TraktWatchlistAddResponseExisting.fromJson(json);
}

/// @nodoc
mixin _$TraktWatchlistAddResponseExisting {
  int get movies => throw _privateConstructorUsedError;
  int get shows => throw _privateConstructorUsedError;
  int get seasons => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktWatchlistAddResponseExistingCopyWith<TraktWatchlistAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktWatchlistAddResponseExistingCopyWith<$Res> {
  factory $TraktWatchlistAddResponseExistingCopyWith(
          TraktWatchlistAddResponseExisting value,
          $Res Function(TraktWatchlistAddResponseExisting) then) =
      _$TraktWatchlistAddResponseExistingCopyWithImpl<$Res,
          TraktWatchlistAddResponseExisting>;
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes});
}

/// @nodoc
class _$TraktWatchlistAddResponseExistingCopyWithImpl<$Res,
        $Val extends TraktWatchlistAddResponseExisting>
    implements $TraktWatchlistAddResponseExistingCopyWith<$Res> {
  _$TraktWatchlistAddResponseExistingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktWatchlistAddResponseExistingCopyWith<$Res>
    implements $TraktWatchlistAddResponseExistingCopyWith<$Res> {
  factory _$$_TraktWatchlistAddResponseExistingCopyWith(
          _$_TraktWatchlistAddResponseExisting value,
          $Res Function(_$_TraktWatchlistAddResponseExisting) then) =
      __$$_TraktWatchlistAddResponseExistingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int shows, int seasons, int episodes});
}

/// @nodoc
class __$$_TraktWatchlistAddResponseExistingCopyWithImpl<$Res>
    extends _$TraktWatchlistAddResponseExistingCopyWithImpl<$Res,
        _$_TraktWatchlistAddResponseExisting>
    implements _$$_TraktWatchlistAddResponseExistingCopyWith<$Res> {
  __$$_TraktWatchlistAddResponseExistingCopyWithImpl(
      _$_TraktWatchlistAddResponseExisting _value,
      $Res Function(_$_TraktWatchlistAddResponseExisting) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktWatchlistAddResponseExisting(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as int,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktWatchlistAddResponseExisting
    implements _TraktWatchlistAddResponseExisting {
  const _$_TraktWatchlistAddResponseExisting(
      {required this.movies,
      required this.shows,
      required this.seasons,
      required this.episodes});

  factory _$_TraktWatchlistAddResponseExisting.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktWatchlistAddResponseExistingFromJson(json);

  @override
  final int movies;
  @override
  final int shows;
  @override
  final int seasons;
  @override
  final int episodes;

  @override
  String toString() {
    return 'TraktWatchlistAddResponseExisting(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktWatchlistAddResponseExisting &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.shows, shows) || other.shows == shows) &&
            (identical(other.seasons, seasons) || other.seasons == seasons) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, movies, shows, seasons, episodes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktWatchlistAddResponseExistingCopyWith<
          _$_TraktWatchlistAddResponseExisting>
      get copyWith => __$$_TraktWatchlistAddResponseExistingCopyWithImpl<
          _$_TraktWatchlistAddResponseExisting>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktWatchlistAddResponseExistingToJson(
      this,
    );
  }
}

abstract class _TraktWatchlistAddResponseExisting
    implements TraktWatchlistAddResponseExisting {
  const factory _TraktWatchlistAddResponseExisting(
      {required final int movies,
      required final int shows,
      required final int seasons,
      required final int episodes}) = _$_TraktWatchlistAddResponseExisting;

  factory _TraktWatchlistAddResponseExisting.fromJson(
          Map<String, dynamic> json) =
      _$_TraktWatchlistAddResponseExisting.fromJson;

  @override
  int get movies;
  @override
  int get shows;
  @override
  int get seasons;
  @override
  int get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktWatchlistAddResponseExistingCopyWith<
          _$_TraktWatchlistAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

TraktWatchlistAddResponseNotFound _$TraktWatchlistAddResponseNotFoundFromJson(
    Map<String, dynamic> json) {
  return _TraktWatchlistAddResponseNotFound.fromJson(json);
}

/// @nodoc
mixin _$TraktWatchlistAddResponseNotFound {
  List<TraktWatchlistAddMovie> get movies => throw _privateConstructorUsedError;
  List<TraktWatchlistAddShow> get shows => throw _privateConstructorUsedError;
  List<TraktWatchlistAddSeason> get seasons =>
      throw _privateConstructorUsedError;
  List<TraktWatchlistAddEpisode> get episodes =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktWatchlistAddResponseNotFoundCopyWith<TraktWatchlistAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktWatchlistAddResponseNotFoundCopyWith<$Res> {
  factory $TraktWatchlistAddResponseNotFoundCopyWith(
          TraktWatchlistAddResponseNotFound value,
          $Res Function(TraktWatchlistAddResponseNotFound) then) =
      _$TraktWatchlistAddResponseNotFoundCopyWithImpl<$Res,
          TraktWatchlistAddResponseNotFound>;
  @useResult
  $Res call(
      {List<TraktWatchlistAddMovie> movies,
      List<TraktWatchlistAddShow> shows,
      List<TraktWatchlistAddSeason> seasons,
      List<TraktWatchlistAddEpisode> episodes});
}

/// @nodoc
class _$TraktWatchlistAddResponseNotFoundCopyWithImpl<$Res,
        $Val extends TraktWatchlistAddResponseNotFound>
    implements $TraktWatchlistAddResponseNotFoundCopyWith<$Res> {
  _$TraktWatchlistAddResponseNotFoundCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddMovie>,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddShow>,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddSeason>,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddEpisode>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktWatchlistAddResponseNotFoundCopyWith<$Res>
    implements $TraktWatchlistAddResponseNotFoundCopyWith<$Res> {
  factory _$$_TraktWatchlistAddResponseNotFoundCopyWith(
          _$_TraktWatchlistAddResponseNotFound value,
          $Res Function(_$_TraktWatchlistAddResponseNotFound) then) =
      __$$_TraktWatchlistAddResponseNotFoundCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TraktWatchlistAddMovie> movies,
      List<TraktWatchlistAddShow> shows,
      List<TraktWatchlistAddSeason> seasons,
      List<TraktWatchlistAddEpisode> episodes});
}

/// @nodoc
class __$$_TraktWatchlistAddResponseNotFoundCopyWithImpl<$Res>
    extends _$TraktWatchlistAddResponseNotFoundCopyWithImpl<$Res,
        _$_TraktWatchlistAddResponseNotFound>
    implements _$$_TraktWatchlistAddResponseNotFoundCopyWith<$Res> {
  __$$_TraktWatchlistAddResponseNotFoundCopyWithImpl(
      _$_TraktWatchlistAddResponseNotFound _value,
      $Res Function(_$_TraktWatchlistAddResponseNotFound) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktWatchlistAddResponseNotFound(
      movies: null == movies
          ? _value._movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddMovie>,
      shows: null == shows
          ? _value._shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddShow>,
      seasons: null == seasons
          ? _value._seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddSeason>,
      episodes: null == episodes
          ? _value._episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktWatchlistAddEpisode>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktWatchlistAddResponseNotFound
    implements _TraktWatchlistAddResponseNotFound {
  const _$_TraktWatchlistAddResponseNotFound(
      {required final List<TraktWatchlistAddMovie> movies,
      required final List<TraktWatchlistAddShow> shows,
      required final List<TraktWatchlistAddSeason> seasons,
      required final List<TraktWatchlistAddEpisode> episodes})
      : _movies = movies,
        _shows = shows,
        _seasons = seasons,
        _episodes = episodes;

  factory _$_TraktWatchlistAddResponseNotFound.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktWatchlistAddResponseNotFoundFromJson(json);

  final List<TraktWatchlistAddMovie> _movies;
  @override
  List<TraktWatchlistAddMovie> get movies {
    if (_movies is EqualUnmodifiableListView) return _movies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_movies);
  }

  final List<TraktWatchlistAddShow> _shows;
  @override
  List<TraktWatchlistAddShow> get shows {
    if (_shows is EqualUnmodifiableListView) return _shows;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_shows);
  }

  final List<TraktWatchlistAddSeason> _seasons;
  @override
  List<TraktWatchlistAddSeason> get seasons {
    if (_seasons is EqualUnmodifiableListView) return _seasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_seasons);
  }

  final List<TraktWatchlistAddEpisode> _episodes;
  @override
  List<TraktWatchlistAddEpisode> get episodes {
    if (_episodes is EqualUnmodifiableListView) return _episodes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_episodes);
  }

  @override
  String toString() {
    return 'TraktWatchlistAddResponseNotFound(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktWatchlistAddResponseNotFound &&
            const DeepCollectionEquality().equals(other._movies, _movies) &&
            const DeepCollectionEquality().equals(other._shows, _shows) &&
            const DeepCollectionEquality().equals(other._seasons, _seasons) &&
            const DeepCollectionEquality().equals(other._episodes, _episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_movies),
      const DeepCollectionEquality().hash(_shows),
      const DeepCollectionEquality().hash(_seasons),
      const DeepCollectionEquality().hash(_episodes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktWatchlistAddResponseNotFoundCopyWith<
          _$_TraktWatchlistAddResponseNotFound>
      get copyWith => __$$_TraktWatchlistAddResponseNotFoundCopyWithImpl<
          _$_TraktWatchlistAddResponseNotFound>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktWatchlistAddResponseNotFoundToJson(
      this,
    );
  }
}

abstract class _TraktWatchlistAddResponseNotFound
    implements TraktWatchlistAddResponseNotFound {
  const factory _TraktWatchlistAddResponseNotFound(
          {required final List<TraktWatchlistAddMovie> movies,
          required final List<TraktWatchlistAddShow> shows,
          required final List<TraktWatchlistAddSeason> seasons,
          required final List<TraktWatchlistAddEpisode> episodes}) =
      _$_TraktWatchlistAddResponseNotFound;

  factory _TraktWatchlistAddResponseNotFound.fromJson(
          Map<String, dynamic> json) =
      _$_TraktWatchlistAddResponseNotFound.fromJson;

  @override
  List<TraktWatchlistAddMovie> get movies;
  @override
  List<TraktWatchlistAddShow> get shows;
  @override
  List<TraktWatchlistAddSeason> get seasons;
  @override
  List<TraktWatchlistAddEpisode> get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktWatchlistAddResponseNotFoundCopyWith<
          _$_TraktWatchlistAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}

TraktWatchlistAddResponseList _$TraktWatchlistAddResponseListFromJson(
    Map<String, dynamic> json) {
  return _TraktWatchlistAddResponseList.fromJson(json);
}

/// @nodoc
mixin _$TraktWatchlistAddResponseList {
  DateTime get updatedAt => throw _privateConstructorUsedError;
  int get itemCount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktWatchlistAddResponseListCopyWith<TraktWatchlistAddResponseList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktWatchlistAddResponseListCopyWith<$Res> {
  factory $TraktWatchlistAddResponseListCopyWith(
          TraktWatchlistAddResponseList value,
          $Res Function(TraktWatchlistAddResponseList) then) =
      _$TraktWatchlistAddResponseListCopyWithImpl<$Res,
          TraktWatchlistAddResponseList>;
  @useResult
  $Res call({DateTime updatedAt, int itemCount});
}

/// @nodoc
class _$TraktWatchlistAddResponseListCopyWithImpl<$Res,
        $Val extends TraktWatchlistAddResponseList>
    implements $TraktWatchlistAddResponseListCopyWith<$Res> {
  _$TraktWatchlistAddResponseListCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updatedAt = null,
    Object? itemCount = null,
  }) {
    return _then(_value.copyWith(
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      itemCount: null == itemCount
          ? _value.itemCount
          : itemCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktWatchlistAddResponseListCopyWith<$Res>
    implements $TraktWatchlistAddResponseListCopyWith<$Res> {
  factory _$$_TraktWatchlistAddResponseListCopyWith(
          _$_TraktWatchlistAddResponseList value,
          $Res Function(_$_TraktWatchlistAddResponseList) then) =
      __$$_TraktWatchlistAddResponseListCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DateTime updatedAt, int itemCount});
}

/// @nodoc
class __$$_TraktWatchlistAddResponseListCopyWithImpl<$Res>
    extends _$TraktWatchlistAddResponseListCopyWithImpl<$Res,
        _$_TraktWatchlistAddResponseList>
    implements _$$_TraktWatchlistAddResponseListCopyWith<$Res> {
  __$$_TraktWatchlistAddResponseListCopyWithImpl(
      _$_TraktWatchlistAddResponseList _value,
      $Res Function(_$_TraktWatchlistAddResponseList) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? updatedAt = null,
    Object? itemCount = null,
  }) {
    return _then(_$_TraktWatchlistAddResponseList(
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      itemCount: null == itemCount
          ? _value.itemCount
          : itemCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktWatchlistAddResponseList
    implements _TraktWatchlistAddResponseList {
  const _$_TraktWatchlistAddResponseList(
      {required this.updatedAt, required this.itemCount});

  factory _$_TraktWatchlistAddResponseList.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktWatchlistAddResponseListFromJson(json);

  @override
  final DateTime updatedAt;
  @override
  final int itemCount;

  @override
  String toString() {
    return 'TraktWatchlistAddResponseList(updatedAt: $updatedAt, itemCount: $itemCount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktWatchlistAddResponseList &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.itemCount, itemCount) ||
                other.itemCount == itemCount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, updatedAt, itemCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktWatchlistAddResponseListCopyWith<_$_TraktWatchlistAddResponseList>
      get copyWith => __$$_TraktWatchlistAddResponseListCopyWithImpl<
          _$_TraktWatchlistAddResponseList>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktWatchlistAddResponseListToJson(
      this,
    );
  }
}

abstract class _TraktWatchlistAddResponseList
    implements TraktWatchlistAddResponseList {
  const factory _TraktWatchlistAddResponseList(
      {required final DateTime updatedAt,
      required final int itemCount}) = _$_TraktWatchlistAddResponseList;

  factory _TraktWatchlistAddResponseList.fromJson(Map<String, dynamic> json) =
      _$_TraktWatchlistAddResponseList.fromJson;

  @override
  DateTime get updatedAt;
  @override
  int get itemCount;
  @override
  @JsonKey(ignore: true)
  _$$_TraktWatchlistAddResponseListCopyWith<_$_TraktWatchlistAddResponseList>
      get copyWith => throw _privateConstructorUsedError;
}
