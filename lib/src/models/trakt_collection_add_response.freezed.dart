// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'trakt_collection_add_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TraktCollectionAddResponse _$TraktCollectionAddResponseFromJson(
    Map<String, dynamic> json) {
  return _TraktCollectionAddResponse.fromJson(json);
}

/// @nodoc
mixin _$TraktCollectionAddResponse {
  TraktCollectionAddResponseAdded get added =>
      throw _privateConstructorUsedError;
  TraktCollectionAddResponseUpdated get updated =>
      throw _privateConstructorUsedError;
  TraktCollectionAddResponseExisting get existing =>
      throw _privateConstructorUsedError;
  TraktCollectionAddResponseNotFound get notFound =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktCollectionAddResponseCopyWith<TraktCollectionAddResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktCollectionAddResponseCopyWith<$Res> {
  factory $TraktCollectionAddResponseCopyWith(TraktCollectionAddResponse value,
          $Res Function(TraktCollectionAddResponse) then) =
      _$TraktCollectionAddResponseCopyWithImpl<$Res,
          TraktCollectionAddResponse>;
  @useResult
  $Res call(
      {TraktCollectionAddResponseAdded added,
      TraktCollectionAddResponseUpdated updated,
      TraktCollectionAddResponseExisting existing,
      TraktCollectionAddResponseNotFound notFound});

  $TraktCollectionAddResponseAddedCopyWith<$Res> get added;
  $TraktCollectionAddResponseUpdatedCopyWith<$Res> get updated;
  $TraktCollectionAddResponseExistingCopyWith<$Res> get existing;
  $TraktCollectionAddResponseNotFoundCopyWith<$Res> get notFound;
}

/// @nodoc
class _$TraktCollectionAddResponseCopyWithImpl<$Res,
        $Val extends TraktCollectionAddResponse>
    implements $TraktCollectionAddResponseCopyWith<$Res> {
  _$TraktCollectionAddResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? updated = null,
    Object? existing = null,
    Object? notFound = null,
  }) {
    return _then(_value.copyWith(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseAdded,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseUpdated,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseNotFound,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktCollectionAddResponseAddedCopyWith<$Res> get added {
    return $TraktCollectionAddResponseAddedCopyWith<$Res>(_value.added,
        (value) {
      return _then(_value.copyWith(added: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktCollectionAddResponseUpdatedCopyWith<$Res> get updated {
    return $TraktCollectionAddResponseUpdatedCopyWith<$Res>(_value.updated,
        (value) {
      return _then(_value.copyWith(updated: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktCollectionAddResponseExistingCopyWith<$Res> get existing {
    return $TraktCollectionAddResponseExistingCopyWith<$Res>(_value.existing,
        (value) {
      return _then(_value.copyWith(existing: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktCollectionAddResponseNotFoundCopyWith<$Res> get notFound {
    return $TraktCollectionAddResponseNotFoundCopyWith<$Res>(_value.notFound,
        (value) {
      return _then(_value.copyWith(notFound: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TraktCollectionAddResponseCopyWith<$Res>
    implements $TraktCollectionAddResponseCopyWith<$Res> {
  factory _$$_TraktCollectionAddResponseCopyWith(
          _$_TraktCollectionAddResponse value,
          $Res Function(_$_TraktCollectionAddResponse) then) =
      __$$_TraktCollectionAddResponseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TraktCollectionAddResponseAdded added,
      TraktCollectionAddResponseUpdated updated,
      TraktCollectionAddResponseExisting existing,
      TraktCollectionAddResponseNotFound notFound});

  @override
  $TraktCollectionAddResponseAddedCopyWith<$Res> get added;
  @override
  $TraktCollectionAddResponseUpdatedCopyWith<$Res> get updated;
  @override
  $TraktCollectionAddResponseExistingCopyWith<$Res> get existing;
  @override
  $TraktCollectionAddResponseNotFoundCopyWith<$Res> get notFound;
}

/// @nodoc
class __$$_TraktCollectionAddResponseCopyWithImpl<$Res>
    extends _$TraktCollectionAddResponseCopyWithImpl<$Res,
        _$_TraktCollectionAddResponse>
    implements _$$_TraktCollectionAddResponseCopyWith<$Res> {
  __$$_TraktCollectionAddResponseCopyWithImpl(
      _$_TraktCollectionAddResponse _value,
      $Res Function(_$_TraktCollectionAddResponse) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? added = null,
    Object? updated = null,
    Object? existing = null,
    Object? notFound = null,
  }) {
    return _then(_$_TraktCollectionAddResponse(
      added: null == added
          ? _value.added
          : added // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseAdded,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseUpdated,
      existing: null == existing
          ? _value.existing
          : existing // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseExisting,
      notFound: null == notFound
          ? _value.notFound
          : notFound // ignore: cast_nullable_to_non_nullable
              as TraktCollectionAddResponseNotFound,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktCollectionAddResponse implements _TraktCollectionAddResponse {
  const _$_TraktCollectionAddResponse(
      {required this.added,
      required this.updated,
      required this.existing,
      required this.notFound});

  factory _$_TraktCollectionAddResponse.fromJson(Map<String, dynamic> json) =>
      _$$_TraktCollectionAddResponseFromJson(json);

  @override
  final TraktCollectionAddResponseAdded added;
  @override
  final TraktCollectionAddResponseUpdated updated;
  @override
  final TraktCollectionAddResponseExisting existing;
  @override
  final TraktCollectionAddResponseNotFound notFound;

  @override
  String toString() {
    return 'TraktCollectionAddResponse(added: $added, updated: $updated, existing: $existing, notFound: $notFound)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktCollectionAddResponse &&
            (identical(other.added, added) || other.added == added) &&
            (identical(other.updated, updated) || other.updated == updated) &&
            (identical(other.existing, existing) ||
                other.existing == existing) &&
            (identical(other.notFound, notFound) ||
                other.notFound == notFound));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, added, updated, existing, notFound);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktCollectionAddResponseCopyWith<_$_TraktCollectionAddResponse>
      get copyWith => __$$_TraktCollectionAddResponseCopyWithImpl<
          _$_TraktCollectionAddResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktCollectionAddResponseToJson(
      this,
    );
  }
}

abstract class _TraktCollectionAddResponse
    implements TraktCollectionAddResponse {
  const factory _TraktCollectionAddResponse(
          {required final TraktCollectionAddResponseAdded added,
          required final TraktCollectionAddResponseUpdated updated,
          required final TraktCollectionAddResponseExisting existing,
          required final TraktCollectionAddResponseNotFound notFound}) =
      _$_TraktCollectionAddResponse;

  factory _TraktCollectionAddResponse.fromJson(Map<String, dynamic> json) =
      _$_TraktCollectionAddResponse.fromJson;

  @override
  TraktCollectionAddResponseAdded get added;
  @override
  TraktCollectionAddResponseUpdated get updated;
  @override
  TraktCollectionAddResponseExisting get existing;
  @override
  TraktCollectionAddResponseNotFound get notFound;
  @override
  @JsonKey(ignore: true)
  _$$_TraktCollectionAddResponseCopyWith<_$_TraktCollectionAddResponse>
      get copyWith => throw _privateConstructorUsedError;
}

TraktCollectionAddResponseAdded _$TraktCollectionAddResponseAddedFromJson(
    Map<String, dynamic> json) {
  return _TraktCollectionAddResponseAdded.fromJson(json);
}

/// @nodoc
mixin _$TraktCollectionAddResponseAdded {
  int get movies => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktCollectionAddResponseAddedCopyWith<TraktCollectionAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktCollectionAddResponseAddedCopyWith<$Res> {
  factory $TraktCollectionAddResponseAddedCopyWith(
          TraktCollectionAddResponseAdded value,
          $Res Function(TraktCollectionAddResponseAdded) then) =
      _$TraktCollectionAddResponseAddedCopyWithImpl<$Res,
          TraktCollectionAddResponseAdded>;
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class _$TraktCollectionAddResponseAddedCopyWithImpl<$Res,
        $Val extends TraktCollectionAddResponseAdded>
    implements $TraktCollectionAddResponseAddedCopyWith<$Res> {
  _$TraktCollectionAddResponseAddedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktCollectionAddResponseAddedCopyWith<$Res>
    implements $TraktCollectionAddResponseAddedCopyWith<$Res> {
  factory _$$_TraktCollectionAddResponseAddedCopyWith(
          _$_TraktCollectionAddResponseAdded value,
          $Res Function(_$_TraktCollectionAddResponseAdded) then) =
      __$$_TraktCollectionAddResponseAddedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class __$$_TraktCollectionAddResponseAddedCopyWithImpl<$Res>
    extends _$TraktCollectionAddResponseAddedCopyWithImpl<$Res,
        _$_TraktCollectionAddResponseAdded>
    implements _$$_TraktCollectionAddResponseAddedCopyWith<$Res> {
  __$$_TraktCollectionAddResponseAddedCopyWithImpl(
      _$_TraktCollectionAddResponseAdded _value,
      $Res Function(_$_TraktCollectionAddResponseAdded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktCollectionAddResponseAdded(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktCollectionAddResponseAdded
    implements _TraktCollectionAddResponseAdded {
  const _$_TraktCollectionAddResponseAdded(
      {required this.movies, required this.episodes});

  factory _$_TraktCollectionAddResponseAdded.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktCollectionAddResponseAddedFromJson(json);

  @override
  final int movies;
  @override
  final int episodes;

  @override
  String toString() {
    return 'TraktCollectionAddResponseAdded(movies: $movies, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktCollectionAddResponseAdded &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, movies, episodes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktCollectionAddResponseAddedCopyWith<
          _$_TraktCollectionAddResponseAdded>
      get copyWith => __$$_TraktCollectionAddResponseAddedCopyWithImpl<
          _$_TraktCollectionAddResponseAdded>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktCollectionAddResponseAddedToJson(
      this,
    );
  }
}

abstract class _TraktCollectionAddResponseAdded
    implements TraktCollectionAddResponseAdded {
  const factory _TraktCollectionAddResponseAdded(
      {required final int movies,
      required final int episodes}) = _$_TraktCollectionAddResponseAdded;

  factory _TraktCollectionAddResponseAdded.fromJson(Map<String, dynamic> json) =
      _$_TraktCollectionAddResponseAdded.fromJson;

  @override
  int get movies;
  @override
  int get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktCollectionAddResponseAddedCopyWith<
          _$_TraktCollectionAddResponseAdded>
      get copyWith => throw _privateConstructorUsedError;
}

TraktCollectionAddResponseUpdated _$TraktCollectionAddResponseUpdatedFromJson(
    Map<String, dynamic> json) {
  return _TraktCollectionAddResponseUpdated.fromJson(json);
}

/// @nodoc
mixin _$TraktCollectionAddResponseUpdated {
  int get movies => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktCollectionAddResponseUpdatedCopyWith<TraktCollectionAddResponseUpdated>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktCollectionAddResponseUpdatedCopyWith<$Res> {
  factory $TraktCollectionAddResponseUpdatedCopyWith(
          TraktCollectionAddResponseUpdated value,
          $Res Function(TraktCollectionAddResponseUpdated) then) =
      _$TraktCollectionAddResponseUpdatedCopyWithImpl<$Res,
          TraktCollectionAddResponseUpdated>;
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class _$TraktCollectionAddResponseUpdatedCopyWithImpl<$Res,
        $Val extends TraktCollectionAddResponseUpdated>
    implements $TraktCollectionAddResponseUpdatedCopyWith<$Res> {
  _$TraktCollectionAddResponseUpdatedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktCollectionAddResponseUpdatedCopyWith<$Res>
    implements $TraktCollectionAddResponseUpdatedCopyWith<$Res> {
  factory _$$_TraktCollectionAddResponseUpdatedCopyWith(
          _$_TraktCollectionAddResponseUpdated value,
          $Res Function(_$_TraktCollectionAddResponseUpdated) then) =
      __$$_TraktCollectionAddResponseUpdatedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class __$$_TraktCollectionAddResponseUpdatedCopyWithImpl<$Res>
    extends _$TraktCollectionAddResponseUpdatedCopyWithImpl<$Res,
        _$_TraktCollectionAddResponseUpdated>
    implements _$$_TraktCollectionAddResponseUpdatedCopyWith<$Res> {
  __$$_TraktCollectionAddResponseUpdatedCopyWithImpl(
      _$_TraktCollectionAddResponseUpdated _value,
      $Res Function(_$_TraktCollectionAddResponseUpdated) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktCollectionAddResponseUpdated(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktCollectionAddResponseUpdated
    implements _TraktCollectionAddResponseUpdated {
  const _$_TraktCollectionAddResponseUpdated(
      {required this.movies, required this.episodes});

  factory _$_TraktCollectionAddResponseUpdated.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktCollectionAddResponseUpdatedFromJson(json);

  @override
  final int movies;
  @override
  final int episodes;

  @override
  String toString() {
    return 'TraktCollectionAddResponseUpdated(movies: $movies, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktCollectionAddResponseUpdated &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, movies, episodes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktCollectionAddResponseUpdatedCopyWith<
          _$_TraktCollectionAddResponseUpdated>
      get copyWith => __$$_TraktCollectionAddResponseUpdatedCopyWithImpl<
          _$_TraktCollectionAddResponseUpdated>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktCollectionAddResponseUpdatedToJson(
      this,
    );
  }
}

abstract class _TraktCollectionAddResponseUpdated
    implements TraktCollectionAddResponseUpdated {
  const factory _TraktCollectionAddResponseUpdated(
      {required final int movies,
      required final int episodes}) = _$_TraktCollectionAddResponseUpdated;

  factory _TraktCollectionAddResponseUpdated.fromJson(
          Map<String, dynamic> json) =
      _$_TraktCollectionAddResponseUpdated.fromJson;

  @override
  int get movies;
  @override
  int get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktCollectionAddResponseUpdatedCopyWith<
          _$_TraktCollectionAddResponseUpdated>
      get copyWith => throw _privateConstructorUsedError;
}

TraktCollectionAddResponseExisting _$TraktCollectionAddResponseExistingFromJson(
    Map<String, dynamic> json) {
  return _TraktCollectionAddResponseExisting.fromJson(json);
}

/// @nodoc
mixin _$TraktCollectionAddResponseExisting {
  int get movies => throw _privateConstructorUsedError;
  int get episodes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktCollectionAddResponseExistingCopyWith<
          TraktCollectionAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktCollectionAddResponseExistingCopyWith<$Res> {
  factory $TraktCollectionAddResponseExistingCopyWith(
          TraktCollectionAddResponseExisting value,
          $Res Function(TraktCollectionAddResponseExisting) then) =
      _$TraktCollectionAddResponseExistingCopyWithImpl<$Res,
          TraktCollectionAddResponseExisting>;
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class _$TraktCollectionAddResponseExistingCopyWithImpl<$Res,
        $Val extends TraktCollectionAddResponseExisting>
    implements $TraktCollectionAddResponseExistingCopyWith<$Res> {
  _$TraktCollectionAddResponseExistingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktCollectionAddResponseExistingCopyWith<$Res>
    implements $TraktCollectionAddResponseExistingCopyWith<$Res> {
  factory _$$_TraktCollectionAddResponseExistingCopyWith(
          _$_TraktCollectionAddResponseExisting value,
          $Res Function(_$_TraktCollectionAddResponseExisting) then) =
      __$$_TraktCollectionAddResponseExistingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int movies, int episodes});
}

/// @nodoc
class __$$_TraktCollectionAddResponseExistingCopyWithImpl<$Res>
    extends _$TraktCollectionAddResponseExistingCopyWithImpl<$Res,
        _$_TraktCollectionAddResponseExisting>
    implements _$$_TraktCollectionAddResponseExistingCopyWith<$Res> {
  __$$_TraktCollectionAddResponseExistingCopyWithImpl(
      _$_TraktCollectionAddResponseExisting _value,
      $Res Function(_$_TraktCollectionAddResponseExisting) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktCollectionAddResponseExisting(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as int,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktCollectionAddResponseExisting
    implements _TraktCollectionAddResponseExisting {
  const _$_TraktCollectionAddResponseExisting(
      {required this.movies, required this.episodes});

  factory _$_TraktCollectionAddResponseExisting.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktCollectionAddResponseExistingFromJson(json);

  @override
  final int movies;
  @override
  final int episodes;

  @override
  String toString() {
    return 'TraktCollectionAddResponseExisting(movies: $movies, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktCollectionAddResponseExisting &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, movies, episodes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktCollectionAddResponseExistingCopyWith<
          _$_TraktCollectionAddResponseExisting>
      get copyWith => __$$_TraktCollectionAddResponseExistingCopyWithImpl<
          _$_TraktCollectionAddResponseExisting>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktCollectionAddResponseExistingToJson(
      this,
    );
  }
}

abstract class _TraktCollectionAddResponseExisting
    implements TraktCollectionAddResponseExisting {
  const factory _TraktCollectionAddResponseExisting(
      {required final int movies,
      required final int episodes}) = _$_TraktCollectionAddResponseExisting;

  factory _TraktCollectionAddResponseExisting.fromJson(
          Map<String, dynamic> json) =
      _$_TraktCollectionAddResponseExisting.fromJson;

  @override
  int get movies;
  @override
  int get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktCollectionAddResponseExistingCopyWith<
          _$_TraktCollectionAddResponseExisting>
      get copyWith => throw _privateConstructorUsedError;
}

TraktCollectionAddResponseNotFound _$TraktCollectionAddResponseNotFoundFromJson(
    Map<String, dynamic> json) {
  return _TraktCollectionAddResponseNotFound.fromJson(json);
}

/// @nodoc
mixin _$TraktCollectionAddResponseNotFound {
  List<TraktCollectionAddMovie> get movies =>
      throw _privateConstructorUsedError;
  List<TraktCollectionAddShow> get shows => throw _privateConstructorUsedError;
  List<TraktCollectionAddSeason> get seasons =>
      throw _privateConstructorUsedError;
  List<TraktCollectionAddEpisode> get episodes =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktCollectionAddResponseNotFoundCopyWith<
          TraktCollectionAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktCollectionAddResponseNotFoundCopyWith<$Res> {
  factory $TraktCollectionAddResponseNotFoundCopyWith(
          TraktCollectionAddResponseNotFound value,
          $Res Function(TraktCollectionAddResponseNotFound) then) =
      _$TraktCollectionAddResponseNotFoundCopyWithImpl<$Res,
          TraktCollectionAddResponseNotFound>;
  @useResult
  $Res call(
      {List<TraktCollectionAddMovie> movies,
      List<TraktCollectionAddShow> shows,
      List<TraktCollectionAddSeason> seasons,
      List<TraktCollectionAddEpisode> episodes});
}

/// @nodoc
class _$TraktCollectionAddResponseNotFoundCopyWithImpl<$Res,
        $Val extends TraktCollectionAddResponseNotFound>
    implements $TraktCollectionAddResponseNotFoundCopyWith<$Res> {
  _$TraktCollectionAddResponseNotFoundCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddMovie>,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddShow>,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddSeason>,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddEpisode>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktCollectionAddResponseNotFoundCopyWith<$Res>
    implements $TraktCollectionAddResponseNotFoundCopyWith<$Res> {
  factory _$$_TraktCollectionAddResponseNotFoundCopyWith(
          _$_TraktCollectionAddResponseNotFound value,
          $Res Function(_$_TraktCollectionAddResponseNotFound) then) =
      __$$_TraktCollectionAddResponseNotFoundCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TraktCollectionAddMovie> movies,
      List<TraktCollectionAddShow> shows,
      List<TraktCollectionAddSeason> seasons,
      List<TraktCollectionAddEpisode> episodes});
}

/// @nodoc
class __$$_TraktCollectionAddResponseNotFoundCopyWithImpl<$Res>
    extends _$TraktCollectionAddResponseNotFoundCopyWithImpl<$Res,
        _$_TraktCollectionAddResponseNotFound>
    implements _$$_TraktCollectionAddResponseNotFoundCopyWith<$Res> {
  __$$_TraktCollectionAddResponseNotFoundCopyWithImpl(
      _$_TraktCollectionAddResponseNotFound _value,
      $Res Function(_$_TraktCollectionAddResponseNotFound) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
  }) {
    return _then(_$_TraktCollectionAddResponseNotFound(
      movies: null == movies
          ? _value._movies
          : movies // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddMovie>,
      shows: null == shows
          ? _value._shows
          : shows // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddShow>,
      seasons: null == seasons
          ? _value._seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddSeason>,
      episodes: null == episodes
          ? _value._episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as List<TraktCollectionAddEpisode>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktCollectionAddResponseNotFound
    implements _TraktCollectionAddResponseNotFound {
  const _$_TraktCollectionAddResponseNotFound(
      {required final List<TraktCollectionAddMovie> movies,
      required final List<TraktCollectionAddShow> shows,
      required final List<TraktCollectionAddSeason> seasons,
      required final List<TraktCollectionAddEpisode> episodes})
      : _movies = movies,
        _shows = shows,
        _seasons = seasons,
        _episodes = episodes;

  factory _$_TraktCollectionAddResponseNotFound.fromJson(
          Map<String, dynamic> json) =>
      _$$_TraktCollectionAddResponseNotFoundFromJson(json);

  final List<TraktCollectionAddMovie> _movies;
  @override
  List<TraktCollectionAddMovie> get movies {
    if (_movies is EqualUnmodifiableListView) return _movies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_movies);
  }

  final List<TraktCollectionAddShow> _shows;
  @override
  List<TraktCollectionAddShow> get shows {
    if (_shows is EqualUnmodifiableListView) return _shows;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_shows);
  }

  final List<TraktCollectionAddSeason> _seasons;
  @override
  List<TraktCollectionAddSeason> get seasons {
    if (_seasons is EqualUnmodifiableListView) return _seasons;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_seasons);
  }

  final List<TraktCollectionAddEpisode> _episodes;
  @override
  List<TraktCollectionAddEpisode> get episodes {
    if (_episodes is EqualUnmodifiableListView) return _episodes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_episodes);
  }

  @override
  String toString() {
    return 'TraktCollectionAddResponseNotFound(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktCollectionAddResponseNotFound &&
            const DeepCollectionEquality().equals(other._movies, _movies) &&
            const DeepCollectionEquality().equals(other._shows, _shows) &&
            const DeepCollectionEquality().equals(other._seasons, _seasons) &&
            const DeepCollectionEquality().equals(other._episodes, _episodes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_movies),
      const DeepCollectionEquality().hash(_shows),
      const DeepCollectionEquality().hash(_seasons),
      const DeepCollectionEquality().hash(_episodes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktCollectionAddResponseNotFoundCopyWith<
          _$_TraktCollectionAddResponseNotFound>
      get copyWith => __$$_TraktCollectionAddResponseNotFoundCopyWithImpl<
          _$_TraktCollectionAddResponseNotFound>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktCollectionAddResponseNotFoundToJson(
      this,
    );
  }
}

abstract class _TraktCollectionAddResponseNotFound
    implements TraktCollectionAddResponseNotFound {
  const factory _TraktCollectionAddResponseNotFound(
          {required final List<TraktCollectionAddMovie> movies,
          required final List<TraktCollectionAddShow> shows,
          required final List<TraktCollectionAddSeason> seasons,
          required final List<TraktCollectionAddEpisode> episodes}) =
      _$_TraktCollectionAddResponseNotFound;

  factory _TraktCollectionAddResponseNotFound.fromJson(
          Map<String, dynamic> json) =
      _$_TraktCollectionAddResponseNotFound.fromJson;

  @override
  List<TraktCollectionAddMovie> get movies;
  @override
  List<TraktCollectionAddShow> get shows;
  @override
  List<TraktCollectionAddSeason> get seasons;
  @override
  List<TraktCollectionAddEpisode> get episodes;
  @override
  @JsonKey(ignore: true)
  _$$_TraktCollectionAddResponseNotFoundCopyWith<
          _$_TraktCollectionAddResponseNotFound>
      get copyWith => throw _privateConstructorUsedError;
}
