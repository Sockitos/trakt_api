// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'trakt_user_stats.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TraktUserStats _$TraktUserStatsFromJson(Map<String, dynamic> json) {
  return _TraktUserStats.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStats {
  TraktUserStatsMovies get movies => throw _privateConstructorUsedError;
  TraktUserStatsShows get shows => throw _privateConstructorUsedError;
  TraktUserStatsSeasons get seasons => throw _privateConstructorUsedError;
  TraktUserStatsEpisodes get episodes => throw _privateConstructorUsedError;
  TraktUserStatsNetwork get network => throw _privateConstructorUsedError;
  TraktUserStatsRatings get ratings => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsCopyWith<TraktUserStats> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsCopyWith<$Res> {
  factory $TraktUserStatsCopyWith(
          TraktUserStats value, $Res Function(TraktUserStats) then) =
      _$TraktUserStatsCopyWithImpl<$Res, TraktUserStats>;
  @useResult
  $Res call(
      {TraktUserStatsMovies movies,
      TraktUserStatsShows shows,
      TraktUserStatsSeasons seasons,
      TraktUserStatsEpisodes episodes,
      TraktUserStatsNetwork network,
      TraktUserStatsRatings ratings});

  $TraktUserStatsMoviesCopyWith<$Res> get movies;
  $TraktUserStatsShowsCopyWith<$Res> get shows;
  $TraktUserStatsSeasonsCopyWith<$Res> get seasons;
  $TraktUserStatsEpisodesCopyWith<$Res> get episodes;
  $TraktUserStatsNetworkCopyWith<$Res> get network;
  $TraktUserStatsRatingsCopyWith<$Res> get ratings;
}

/// @nodoc
class _$TraktUserStatsCopyWithImpl<$Res, $Val extends TraktUserStats>
    implements $TraktUserStatsCopyWith<$Res> {
  _$TraktUserStatsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? network = null,
    Object? ratings = null,
  }) {
    return _then(_value.copyWith(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsMovies,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsShows,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsSeasons,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsEpisodes,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsNetwork,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsRatings,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsMoviesCopyWith<$Res> get movies {
    return $TraktUserStatsMoviesCopyWith<$Res>(_value.movies, (value) {
      return _then(_value.copyWith(movies: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsShowsCopyWith<$Res> get shows {
    return $TraktUserStatsShowsCopyWith<$Res>(_value.shows, (value) {
      return _then(_value.copyWith(shows: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsSeasonsCopyWith<$Res> get seasons {
    return $TraktUserStatsSeasonsCopyWith<$Res>(_value.seasons, (value) {
      return _then(_value.copyWith(seasons: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsEpisodesCopyWith<$Res> get episodes {
    return $TraktUserStatsEpisodesCopyWith<$Res>(_value.episodes, (value) {
      return _then(_value.copyWith(episodes: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsNetworkCopyWith<$Res> get network {
    return $TraktUserStatsNetworkCopyWith<$Res>(_value.network, (value) {
      return _then(_value.copyWith(network: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TraktUserStatsRatingsCopyWith<$Res> get ratings {
    return $TraktUserStatsRatingsCopyWith<$Res>(_value.ratings, (value) {
      return _then(_value.copyWith(ratings: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsCopyWith<$Res>
    implements $TraktUserStatsCopyWith<$Res> {
  factory _$$_TraktUserStatsCopyWith(
          _$_TraktUserStats value, $Res Function(_$_TraktUserStats) then) =
      __$$_TraktUserStatsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TraktUserStatsMovies movies,
      TraktUserStatsShows shows,
      TraktUserStatsSeasons seasons,
      TraktUserStatsEpisodes episodes,
      TraktUserStatsNetwork network,
      TraktUserStatsRatings ratings});

  @override
  $TraktUserStatsMoviesCopyWith<$Res> get movies;
  @override
  $TraktUserStatsShowsCopyWith<$Res> get shows;
  @override
  $TraktUserStatsSeasonsCopyWith<$Res> get seasons;
  @override
  $TraktUserStatsEpisodesCopyWith<$Res> get episodes;
  @override
  $TraktUserStatsNetworkCopyWith<$Res> get network;
  @override
  $TraktUserStatsRatingsCopyWith<$Res> get ratings;
}

/// @nodoc
class __$$_TraktUserStatsCopyWithImpl<$Res>
    extends _$TraktUserStatsCopyWithImpl<$Res, _$_TraktUserStats>
    implements _$$_TraktUserStatsCopyWith<$Res> {
  __$$_TraktUserStatsCopyWithImpl(
      _$_TraktUserStats _value, $Res Function(_$_TraktUserStats) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? movies = null,
    Object? shows = null,
    Object? seasons = null,
    Object? episodes = null,
    Object? network = null,
    Object? ratings = null,
  }) {
    return _then(_$_TraktUserStats(
      movies: null == movies
          ? _value.movies
          : movies // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsMovies,
      shows: null == shows
          ? _value.shows
          : shows // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsShows,
      seasons: null == seasons
          ? _value.seasons
          : seasons // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsSeasons,
      episodes: null == episodes
          ? _value.episodes
          : episodes // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsEpisodes,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsNetwork,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as TraktUserStatsRatings,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStats implements _TraktUserStats {
  const _$_TraktUserStats(
      {required this.movies,
      required this.shows,
      required this.seasons,
      required this.episodes,
      required this.network,
      required this.ratings});

  factory _$_TraktUserStats.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsFromJson(json);

  @override
  final TraktUserStatsMovies movies;
  @override
  final TraktUserStatsShows shows;
  @override
  final TraktUserStatsSeasons seasons;
  @override
  final TraktUserStatsEpisodes episodes;
  @override
  final TraktUserStatsNetwork network;
  @override
  final TraktUserStatsRatings ratings;

  @override
  String toString() {
    return 'TraktUserStats(movies: $movies, shows: $shows, seasons: $seasons, episodes: $episodes, network: $network, ratings: $ratings)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStats &&
            (identical(other.movies, movies) || other.movies == movies) &&
            (identical(other.shows, shows) || other.shows == shows) &&
            (identical(other.seasons, seasons) || other.seasons == seasons) &&
            (identical(other.episodes, episodes) ||
                other.episodes == episodes) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.ratings, ratings) || other.ratings == ratings));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, movies, shows, seasons, episodes, network, ratings);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsCopyWith<_$_TraktUserStats> get copyWith =>
      __$$_TraktUserStatsCopyWithImpl<_$_TraktUserStats>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsToJson(
      this,
    );
  }
}

abstract class _TraktUserStats implements TraktUserStats {
  const factory _TraktUserStats(
      {required final TraktUserStatsMovies movies,
      required final TraktUserStatsShows shows,
      required final TraktUserStatsSeasons seasons,
      required final TraktUserStatsEpisodes episodes,
      required final TraktUserStatsNetwork network,
      required final TraktUserStatsRatings ratings}) = _$_TraktUserStats;

  factory _TraktUserStats.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStats.fromJson;

  @override
  TraktUserStatsMovies get movies;
  @override
  TraktUserStatsShows get shows;
  @override
  TraktUserStatsSeasons get seasons;
  @override
  TraktUserStatsEpisodes get episodes;
  @override
  TraktUserStatsNetwork get network;
  @override
  TraktUserStatsRatings get ratings;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsCopyWith<_$_TraktUserStats> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsMovies _$TraktUserStatsMoviesFromJson(Map<String, dynamic> json) {
  return _TraktUserStatsMovies.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsMovies {
  int get plays => throw _privateConstructorUsedError;
  int get watched => throw _privateConstructorUsedError;
  int get minutes => throw _privateConstructorUsedError;
  int get collected => throw _privateConstructorUsedError;
  int get ratings => throw _privateConstructorUsedError;
  int get comments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsMoviesCopyWith<TraktUserStatsMovies> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsMoviesCopyWith<$Res> {
  factory $TraktUserStatsMoviesCopyWith(TraktUserStatsMovies value,
          $Res Function(TraktUserStatsMovies) then) =
      _$TraktUserStatsMoviesCopyWithImpl<$Res, TraktUserStatsMovies>;
  @useResult
  $Res call(
      {int plays,
      int watched,
      int minutes,
      int collected,
      int ratings,
      int comments});
}

/// @nodoc
class _$TraktUserStatsMoviesCopyWithImpl<$Res,
        $Val extends TraktUserStatsMovies>
    implements $TraktUserStatsMoviesCopyWith<$Res> {
  _$TraktUserStatsMoviesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plays = null,
    Object? watched = null,
    Object? minutes = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_value.copyWith(
      plays: null == plays
          ? _value.plays
          : plays // ignore: cast_nullable_to_non_nullable
              as int,
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsMoviesCopyWith<$Res>
    implements $TraktUserStatsMoviesCopyWith<$Res> {
  factory _$$_TraktUserStatsMoviesCopyWith(_$_TraktUserStatsMovies value,
          $Res Function(_$_TraktUserStatsMovies) then) =
      __$$_TraktUserStatsMoviesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int plays,
      int watched,
      int minutes,
      int collected,
      int ratings,
      int comments});
}

/// @nodoc
class __$$_TraktUserStatsMoviesCopyWithImpl<$Res>
    extends _$TraktUserStatsMoviesCopyWithImpl<$Res, _$_TraktUserStatsMovies>
    implements _$$_TraktUserStatsMoviesCopyWith<$Res> {
  __$$_TraktUserStatsMoviesCopyWithImpl(_$_TraktUserStatsMovies _value,
      $Res Function(_$_TraktUserStatsMovies) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plays = null,
    Object? watched = null,
    Object? minutes = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_$_TraktUserStatsMovies(
      plays: null == plays
          ? _value.plays
          : plays // ignore: cast_nullable_to_non_nullable
              as int,
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsMovies implements _TraktUserStatsMovies {
  const _$_TraktUserStatsMovies(
      {required this.plays,
      required this.watched,
      required this.minutes,
      required this.collected,
      required this.ratings,
      required this.comments});

  factory _$_TraktUserStatsMovies.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsMoviesFromJson(json);

  @override
  final int plays;
  @override
  final int watched;
  @override
  final int minutes;
  @override
  final int collected;
  @override
  final int ratings;
  @override
  final int comments;

  @override
  String toString() {
    return 'TraktUserStatsMovies(plays: $plays, watched: $watched, minutes: $minutes, collected: $collected, ratings: $ratings, comments: $comments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsMovies &&
            (identical(other.plays, plays) || other.plays == plays) &&
            (identical(other.watched, watched) || other.watched == watched) &&
            (identical(other.minutes, minutes) || other.minutes == minutes) &&
            (identical(other.collected, collected) ||
                other.collected == collected) &&
            (identical(other.ratings, ratings) || other.ratings == ratings) &&
            (identical(other.comments, comments) ||
                other.comments == comments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, plays, watched, minutes, collected, ratings, comments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsMoviesCopyWith<_$_TraktUserStatsMovies> get copyWith =>
      __$$_TraktUserStatsMoviesCopyWithImpl<_$_TraktUserStatsMovies>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsMoviesToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsMovies implements TraktUserStatsMovies {
  const factory _TraktUserStatsMovies(
      {required final int plays,
      required final int watched,
      required final int minutes,
      required final int collected,
      required final int ratings,
      required final int comments}) = _$_TraktUserStatsMovies;

  factory _TraktUserStatsMovies.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsMovies.fromJson;

  @override
  int get plays;
  @override
  int get watched;
  @override
  int get minutes;
  @override
  int get collected;
  @override
  int get ratings;
  @override
  int get comments;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsMoviesCopyWith<_$_TraktUserStatsMovies> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsShows _$TraktUserStatsShowsFromJson(Map<String, dynamic> json) {
  return _TraktUserStatsShows.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsShows {
  int get watched => throw _privateConstructorUsedError;
  int get collected => throw _privateConstructorUsedError;
  int get ratings => throw _privateConstructorUsedError;
  int get comments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsShowsCopyWith<TraktUserStatsShows> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsShowsCopyWith<$Res> {
  factory $TraktUserStatsShowsCopyWith(
          TraktUserStatsShows value, $Res Function(TraktUserStatsShows) then) =
      _$TraktUserStatsShowsCopyWithImpl<$Res, TraktUserStatsShows>;
  @useResult
  $Res call({int watched, int collected, int ratings, int comments});
}

/// @nodoc
class _$TraktUserStatsShowsCopyWithImpl<$Res, $Val extends TraktUserStatsShows>
    implements $TraktUserStatsShowsCopyWith<$Res> {
  _$TraktUserStatsShowsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? watched = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_value.copyWith(
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsShowsCopyWith<$Res>
    implements $TraktUserStatsShowsCopyWith<$Res> {
  factory _$$_TraktUserStatsShowsCopyWith(_$_TraktUserStatsShows value,
          $Res Function(_$_TraktUserStatsShows) then) =
      __$$_TraktUserStatsShowsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int watched, int collected, int ratings, int comments});
}

/// @nodoc
class __$$_TraktUserStatsShowsCopyWithImpl<$Res>
    extends _$TraktUserStatsShowsCopyWithImpl<$Res, _$_TraktUserStatsShows>
    implements _$$_TraktUserStatsShowsCopyWith<$Res> {
  __$$_TraktUserStatsShowsCopyWithImpl(_$_TraktUserStatsShows _value,
      $Res Function(_$_TraktUserStatsShows) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? watched = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_$_TraktUserStatsShows(
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsShows implements _TraktUserStatsShows {
  const _$_TraktUserStatsShows(
      {required this.watched,
      required this.collected,
      required this.ratings,
      required this.comments});

  factory _$_TraktUserStatsShows.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsShowsFromJson(json);

  @override
  final int watched;
  @override
  final int collected;
  @override
  final int ratings;
  @override
  final int comments;

  @override
  String toString() {
    return 'TraktUserStatsShows(watched: $watched, collected: $collected, ratings: $ratings, comments: $comments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsShows &&
            (identical(other.watched, watched) || other.watched == watched) &&
            (identical(other.collected, collected) ||
                other.collected == collected) &&
            (identical(other.ratings, ratings) || other.ratings == ratings) &&
            (identical(other.comments, comments) ||
                other.comments == comments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, watched, collected, ratings, comments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsShowsCopyWith<_$_TraktUserStatsShows> get copyWith =>
      __$$_TraktUserStatsShowsCopyWithImpl<_$_TraktUserStatsShows>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsShowsToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsShows implements TraktUserStatsShows {
  const factory _TraktUserStatsShows(
      {required final int watched,
      required final int collected,
      required final int ratings,
      required final int comments}) = _$_TraktUserStatsShows;

  factory _TraktUserStatsShows.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsShows.fromJson;

  @override
  int get watched;
  @override
  int get collected;
  @override
  int get ratings;
  @override
  int get comments;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsShowsCopyWith<_$_TraktUserStatsShows> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsSeasons _$TraktUserStatsSeasonsFromJson(
    Map<String, dynamic> json) {
  return _TraktUserStatsSeasons.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsSeasons {
  int get ratings => throw _privateConstructorUsedError;
  int get comments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsSeasonsCopyWith<TraktUserStatsSeasons> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsSeasonsCopyWith<$Res> {
  factory $TraktUserStatsSeasonsCopyWith(TraktUserStatsSeasons value,
          $Res Function(TraktUserStatsSeasons) then) =
      _$TraktUserStatsSeasonsCopyWithImpl<$Res, TraktUserStatsSeasons>;
  @useResult
  $Res call({int ratings, int comments});
}

/// @nodoc
class _$TraktUserStatsSeasonsCopyWithImpl<$Res,
        $Val extends TraktUserStatsSeasons>
    implements $TraktUserStatsSeasonsCopyWith<$Res> {
  _$TraktUserStatsSeasonsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_value.copyWith(
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsSeasonsCopyWith<$Res>
    implements $TraktUserStatsSeasonsCopyWith<$Res> {
  factory _$$_TraktUserStatsSeasonsCopyWith(_$_TraktUserStatsSeasons value,
          $Res Function(_$_TraktUserStatsSeasons) then) =
      __$$_TraktUserStatsSeasonsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int ratings, int comments});
}

/// @nodoc
class __$$_TraktUserStatsSeasonsCopyWithImpl<$Res>
    extends _$TraktUserStatsSeasonsCopyWithImpl<$Res, _$_TraktUserStatsSeasons>
    implements _$$_TraktUserStatsSeasonsCopyWith<$Res> {
  __$$_TraktUserStatsSeasonsCopyWithImpl(_$_TraktUserStatsSeasons _value,
      $Res Function(_$_TraktUserStatsSeasons) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_$_TraktUserStatsSeasons(
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsSeasons implements _TraktUserStatsSeasons {
  const _$_TraktUserStatsSeasons(
      {required this.ratings, required this.comments});

  factory _$_TraktUserStatsSeasons.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsSeasonsFromJson(json);

  @override
  final int ratings;
  @override
  final int comments;

  @override
  String toString() {
    return 'TraktUserStatsSeasons(ratings: $ratings, comments: $comments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsSeasons &&
            (identical(other.ratings, ratings) || other.ratings == ratings) &&
            (identical(other.comments, comments) ||
                other.comments == comments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, ratings, comments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsSeasonsCopyWith<_$_TraktUserStatsSeasons> get copyWith =>
      __$$_TraktUserStatsSeasonsCopyWithImpl<_$_TraktUserStatsSeasons>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsSeasonsToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsSeasons implements TraktUserStatsSeasons {
  const factory _TraktUserStatsSeasons(
      {required final int ratings,
      required final int comments}) = _$_TraktUserStatsSeasons;

  factory _TraktUserStatsSeasons.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsSeasons.fromJson;

  @override
  int get ratings;
  @override
  int get comments;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsSeasonsCopyWith<_$_TraktUserStatsSeasons> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsEpisodes _$TraktUserStatsEpisodesFromJson(
    Map<String, dynamic> json) {
  return _TraktUserStatsEpisodes.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsEpisodes {
  int get plays => throw _privateConstructorUsedError;
  int get watched => throw _privateConstructorUsedError;
  int get minutes => throw _privateConstructorUsedError;
  int get collected => throw _privateConstructorUsedError;
  int get ratings => throw _privateConstructorUsedError;
  int get comments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsEpisodesCopyWith<TraktUserStatsEpisodes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsEpisodesCopyWith<$Res> {
  factory $TraktUserStatsEpisodesCopyWith(TraktUserStatsEpisodes value,
          $Res Function(TraktUserStatsEpisodes) then) =
      _$TraktUserStatsEpisodesCopyWithImpl<$Res, TraktUserStatsEpisodes>;
  @useResult
  $Res call(
      {int plays,
      int watched,
      int minutes,
      int collected,
      int ratings,
      int comments});
}

/// @nodoc
class _$TraktUserStatsEpisodesCopyWithImpl<$Res,
        $Val extends TraktUserStatsEpisodes>
    implements $TraktUserStatsEpisodesCopyWith<$Res> {
  _$TraktUserStatsEpisodesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plays = null,
    Object? watched = null,
    Object? minutes = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_value.copyWith(
      plays: null == plays
          ? _value.plays
          : plays // ignore: cast_nullable_to_non_nullable
              as int,
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsEpisodesCopyWith<$Res>
    implements $TraktUserStatsEpisodesCopyWith<$Res> {
  factory _$$_TraktUserStatsEpisodesCopyWith(_$_TraktUserStatsEpisodes value,
          $Res Function(_$_TraktUserStatsEpisodes) then) =
      __$$_TraktUserStatsEpisodesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int plays,
      int watched,
      int minutes,
      int collected,
      int ratings,
      int comments});
}

/// @nodoc
class __$$_TraktUserStatsEpisodesCopyWithImpl<$Res>
    extends _$TraktUserStatsEpisodesCopyWithImpl<$Res,
        _$_TraktUserStatsEpisodes>
    implements _$$_TraktUserStatsEpisodesCopyWith<$Res> {
  __$$_TraktUserStatsEpisodesCopyWithImpl(_$_TraktUserStatsEpisodes _value,
      $Res Function(_$_TraktUserStatsEpisodes) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plays = null,
    Object? watched = null,
    Object? minutes = null,
    Object? collected = null,
    Object? ratings = null,
    Object? comments = null,
  }) {
    return _then(_$_TraktUserStatsEpisodes(
      plays: null == plays
          ? _value.plays
          : plays // ignore: cast_nullable_to_non_nullable
              as int,
      watched: null == watched
          ? _value.watched
          : watched // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      collected: null == collected
          ? _value.collected
          : collected // ignore: cast_nullable_to_non_nullable
              as int,
      ratings: null == ratings
          ? _value.ratings
          : ratings // ignore: cast_nullable_to_non_nullable
              as int,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsEpisodes implements _TraktUserStatsEpisodes {
  const _$_TraktUserStatsEpisodes(
      {required this.plays,
      required this.watched,
      required this.minutes,
      required this.collected,
      required this.ratings,
      required this.comments});

  factory _$_TraktUserStatsEpisodes.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsEpisodesFromJson(json);

  @override
  final int plays;
  @override
  final int watched;
  @override
  final int minutes;
  @override
  final int collected;
  @override
  final int ratings;
  @override
  final int comments;

  @override
  String toString() {
    return 'TraktUserStatsEpisodes(plays: $plays, watched: $watched, minutes: $minutes, collected: $collected, ratings: $ratings, comments: $comments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsEpisodes &&
            (identical(other.plays, plays) || other.plays == plays) &&
            (identical(other.watched, watched) || other.watched == watched) &&
            (identical(other.minutes, minutes) || other.minutes == minutes) &&
            (identical(other.collected, collected) ||
                other.collected == collected) &&
            (identical(other.ratings, ratings) || other.ratings == ratings) &&
            (identical(other.comments, comments) ||
                other.comments == comments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, plays, watched, minutes, collected, ratings, comments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsEpisodesCopyWith<_$_TraktUserStatsEpisodes> get copyWith =>
      __$$_TraktUserStatsEpisodesCopyWithImpl<_$_TraktUserStatsEpisodes>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsEpisodesToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsEpisodes implements TraktUserStatsEpisodes {
  const factory _TraktUserStatsEpisodes(
      {required final int plays,
      required final int watched,
      required final int minutes,
      required final int collected,
      required final int ratings,
      required final int comments}) = _$_TraktUserStatsEpisodes;

  factory _TraktUserStatsEpisodes.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsEpisodes.fromJson;

  @override
  int get plays;
  @override
  int get watched;
  @override
  int get minutes;
  @override
  int get collected;
  @override
  int get ratings;
  @override
  int get comments;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsEpisodesCopyWith<_$_TraktUserStatsEpisodes> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsNetwork _$TraktUserStatsNetworkFromJson(
    Map<String, dynamic> json) {
  return _TraktUserStatsNetwork.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsNetwork {
  int get friends => throw _privateConstructorUsedError;
  int get followers => throw _privateConstructorUsedError;
  int get following => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsNetworkCopyWith<TraktUserStatsNetwork> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsNetworkCopyWith<$Res> {
  factory $TraktUserStatsNetworkCopyWith(TraktUserStatsNetwork value,
          $Res Function(TraktUserStatsNetwork) then) =
      _$TraktUserStatsNetworkCopyWithImpl<$Res, TraktUserStatsNetwork>;
  @useResult
  $Res call({int friends, int followers, int following});
}

/// @nodoc
class _$TraktUserStatsNetworkCopyWithImpl<$Res,
        $Val extends TraktUserStatsNetwork>
    implements $TraktUserStatsNetworkCopyWith<$Res> {
  _$TraktUserStatsNetworkCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? followers = null,
    Object? following = null,
  }) {
    return _then(_value.copyWith(
      friends: null == friends
          ? _value.friends
          : friends // ignore: cast_nullable_to_non_nullable
              as int,
      followers: null == followers
          ? _value.followers
          : followers // ignore: cast_nullable_to_non_nullable
              as int,
      following: null == following
          ? _value.following
          : following // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsNetworkCopyWith<$Res>
    implements $TraktUserStatsNetworkCopyWith<$Res> {
  factory _$$_TraktUserStatsNetworkCopyWith(_$_TraktUserStatsNetwork value,
          $Res Function(_$_TraktUserStatsNetwork) then) =
      __$$_TraktUserStatsNetworkCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int friends, int followers, int following});
}

/// @nodoc
class __$$_TraktUserStatsNetworkCopyWithImpl<$Res>
    extends _$TraktUserStatsNetworkCopyWithImpl<$Res, _$_TraktUserStatsNetwork>
    implements _$$_TraktUserStatsNetworkCopyWith<$Res> {
  __$$_TraktUserStatsNetworkCopyWithImpl(_$_TraktUserStatsNetwork _value,
      $Res Function(_$_TraktUserStatsNetwork) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? followers = null,
    Object? following = null,
  }) {
    return _then(_$_TraktUserStatsNetwork(
      friends: null == friends
          ? _value.friends
          : friends // ignore: cast_nullable_to_non_nullable
              as int,
      followers: null == followers
          ? _value.followers
          : followers // ignore: cast_nullable_to_non_nullable
              as int,
      following: null == following
          ? _value.following
          : following // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsNetwork implements _TraktUserStatsNetwork {
  const _$_TraktUserStatsNetwork(
      {required this.friends,
      required this.followers,
      required this.following});

  factory _$_TraktUserStatsNetwork.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsNetworkFromJson(json);

  @override
  final int friends;
  @override
  final int followers;
  @override
  final int following;

  @override
  String toString() {
    return 'TraktUserStatsNetwork(friends: $friends, followers: $followers, following: $following)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsNetwork &&
            (identical(other.friends, friends) || other.friends == friends) &&
            (identical(other.followers, followers) ||
                other.followers == followers) &&
            (identical(other.following, following) ||
                other.following == following));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, friends, followers, following);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsNetworkCopyWith<_$_TraktUserStatsNetwork> get copyWith =>
      __$$_TraktUserStatsNetworkCopyWithImpl<_$_TraktUserStatsNetwork>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsNetworkToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsNetwork implements TraktUserStatsNetwork {
  const factory _TraktUserStatsNetwork(
      {required final int friends,
      required final int followers,
      required final int following}) = _$_TraktUserStatsNetwork;

  factory _TraktUserStatsNetwork.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsNetwork.fromJson;

  @override
  int get friends;
  @override
  int get followers;
  @override
  int get following;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsNetworkCopyWith<_$_TraktUserStatsNetwork> get copyWith =>
      throw _privateConstructorUsedError;
}

TraktUserStatsRatings _$TraktUserStatsRatingsFromJson(
    Map<String, dynamic> json) {
  return _TraktUserStatsRatings.fromJson(json);
}

/// @nodoc
mixin _$TraktUserStatsRatings {
  int get total => throw _privateConstructorUsedError;
  Map<String, int> get distribution => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TraktUserStatsRatingsCopyWith<TraktUserStatsRatings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraktUserStatsRatingsCopyWith<$Res> {
  factory $TraktUserStatsRatingsCopyWith(TraktUserStatsRatings value,
          $Res Function(TraktUserStatsRatings) then) =
      _$TraktUserStatsRatingsCopyWithImpl<$Res, TraktUserStatsRatings>;
  @useResult
  $Res call({int total, Map<String, int> distribution});
}

/// @nodoc
class _$TraktUserStatsRatingsCopyWithImpl<$Res,
        $Val extends TraktUserStatsRatings>
    implements $TraktUserStatsRatingsCopyWith<$Res> {
  _$TraktUserStatsRatingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? distribution = null,
  }) {
    return _then(_value.copyWith(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      distribution: null == distribution
          ? _value.distribution
          : distribution // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TraktUserStatsRatingsCopyWith<$Res>
    implements $TraktUserStatsRatingsCopyWith<$Res> {
  factory _$$_TraktUserStatsRatingsCopyWith(_$_TraktUserStatsRatings value,
          $Res Function(_$_TraktUserStatsRatings) then) =
      __$$_TraktUserStatsRatingsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int total, Map<String, int> distribution});
}

/// @nodoc
class __$$_TraktUserStatsRatingsCopyWithImpl<$Res>
    extends _$TraktUserStatsRatingsCopyWithImpl<$Res, _$_TraktUserStatsRatings>
    implements _$$_TraktUserStatsRatingsCopyWith<$Res> {
  __$$_TraktUserStatsRatingsCopyWithImpl(_$_TraktUserStatsRatings _value,
      $Res Function(_$_TraktUserStatsRatings) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? distribution = null,
  }) {
    return _then(_$_TraktUserStatsRatings(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      distribution: null == distribution
          ? _value._distribution
          : distribution // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TraktUserStatsRatings implements _TraktUserStatsRatings {
  const _$_TraktUserStatsRatings(
      {required this.total, required final Map<String, int> distribution})
      : _distribution = distribution;

  factory _$_TraktUserStatsRatings.fromJson(Map<String, dynamic> json) =>
      _$$_TraktUserStatsRatingsFromJson(json);

  @override
  final int total;
  final Map<String, int> _distribution;
  @override
  Map<String, int> get distribution {
    if (_distribution is EqualUnmodifiableMapView) return _distribution;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_distribution);
  }

  @override
  String toString() {
    return 'TraktUserStatsRatings(total: $total, distribution: $distribution)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TraktUserStatsRatings &&
            (identical(other.total, total) || other.total == total) &&
            const DeepCollectionEquality()
                .equals(other._distribution, _distribution));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, total, const DeepCollectionEquality().hash(_distribution));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TraktUserStatsRatingsCopyWith<_$_TraktUserStatsRatings> get copyWith =>
      __$$_TraktUserStatsRatingsCopyWithImpl<_$_TraktUserStatsRatings>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TraktUserStatsRatingsToJson(
      this,
    );
  }
}

abstract class _TraktUserStatsRatings implements TraktUserStatsRatings {
  const factory _TraktUserStatsRatings(
      {required final int total,
      required final Map<String, int> distribution}) = _$_TraktUserStatsRatings;

  factory _TraktUserStatsRatings.fromJson(Map<String, dynamic> json) =
      _$_TraktUserStatsRatings.fromJson;

  @override
  int get total;
  @override
  Map<String, int> get distribution;
  @override
  @JsonKey(ignore: true)
  _$$_TraktUserStatsRatingsCopyWith<_$_TraktUserStatsRatings> get copyWith =>
      throw _privateConstructorUsedError;
}
